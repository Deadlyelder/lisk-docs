= Lisk Framework
Mona Bärenfänger <mona@lightcurve.io>
:description: The Lisk Framework overview provides a high-level synopsis of the Lisk Framework architecture, including its modules and components, how they communicate, and also how to change the default configuration.
//:page-aliases: lisk-framework/index.adoc
:toc: preamble
:v_core: 3.0.0
:imagesdir: ../../assets/images
:page-no-next: true
:page-previous: /lisk-sdk/references/lisk-elements/index.html
:page-previous-title: Lisk Elements

:url_github_lip05: https://github.com/LiskHQ/lips/blob/master/proposals/lip-0005.md
:url_github_lip11: https://github.com/LiskHQ/lips/blob/master/proposals/lip-0011.md

:url_reference_config: references/config.adoc

:url_core_reference_config: {v_core}@lisk-core::reference/config.adoc
:url_guides_config: guides/app-development/configuration.adoc

image:banner_framework.png[Logo]


== Application

.Interface of the Application class
[source,typescript]
----
interface Application {
    registerModule: (moduleClass: typeof BaseModule) => void; <1>
    registerPlugin: (pluginClass: typeof BasePlugin) => void; <2>
    //
    run: () => Promise<void>; <3>
    //
    shutdown: (errorCode: number, message: string) => Promise<void> <4>
    //
    networkIdentifier: Buffer; <5>
    //
    getSchema: () => { <6>
        account: Schema;
        Block: Schema;
        blockHeader: Schema;
        blockHeaderAssets: { [blockVersion: number]: Schema };
        transaction: Schema;
        transactionsAssets: {
            moduleID: number;
            moduleName: string;
            assetID: number;
            assetName: string;
            schema: Schema;
        }
    }
}
----

<1> Adds a module to the application
<2> Adds a plugin to the application.
<3> Starts the application.
<4> Shutdown stops the application with given code and message.
<5> NetworkIdentifer used to sign block and transactions.
<6> getSchema returns all schema definitions that are registered to the application.
Schema is a type defined by codec, which is a Lisk JSON schema.

== The BaseModule

.Interface of the BaseModule
[source,js]
----
class BaseModule {
  public name: string; <1>
  public id: number; <2>
  public transactionAssets: BaseAsset[]; <3>
  public accountSchema?: Schema; <4>
  public actions?: Map<string, ActionHandler>; <5>
  public events?: string[]; <6>
  public reducers?: Map<string, ReduceHandler>; <7>
  public beforeTransactionApply?: ({tx: Transaction, stateStore: StateStore, moduleAccess}) => void; <8>
  public afterTransactionApply?: ({tx: Transaction, stateStore: StateStore, moduleAccess}) => void; <9>
  public afterGenesisBlockApply?: ({block: GenesisBlock, stateStore: StateStore, consensus: Consensus, moduleAccess}) => void; <10>
  public beforeBlockApply?: ({block: Block, stateStore: StateStore, moduleAccess}) => void; <11>
  public afterBlockApply?: ({block: Block, stateStore: StateStore, consensus: Consensus, moduleAccess}) => void; <12>
}
----

<1> Required. Name of the module.
<2> Required. Module ID.
<3> Optional. List of transaction assets for this module
<4> Optional. Schema of account asset to be used in this module
<5> Optional. Set of actions which can be called from framework
<6> Optional. Set of events name that will be emitted from this module
<7> Optional. Set of actions which can be called from other modules during the block processing
<8> Optional. A function which will be called for all transactions regardless of modules.
<9> Optional. A function which will be called for all transactions regardless of modules.
<10> Optional. A function which will be called while applying genesis block
<11> Optional. A function which will be called in sequence at beforeBlockApply step
<12> Optional. A function which will be called in sequence at afterBlockApply step

== The BaseAsset

.Interface of the BaseAsset
[source,js]
----
class BaseAsset<K> {
  public name: string; <1>
  public id: number; <2>
  public schema: Schema; <3>
  public apply: ({senderID:Buffer, asset: K, stateStore: StateStore, transaction: Transaction }) => void; <4>
  public validate?: (asset: K) => void; <5>
}
----

<1> Name of the asset which will be used in the UI
<2> Type of the asset which will be used in the Transaction
<3> Schema of the content of this asset
<4> Validation function that can be implemented if additional
<5> Optional. Validation function that can be implemented if additional

== The BasePlugin

.Interface of the BasePlugin
[source,js]
----
class BasePlugin {

    static get alias(): string; <1>

    static get info(): { <2>
      author: string,
      version: string,
      name: string,
    };

    get defaults(): Record<string, unknown>; <3>

    get events(): string[]; <4>

    get actions(): { [actionName: string]: actionHandler }; <5>

    async load(channel): Promise<void>; <6>

    async unload(): Promise<void>; <7>
};
----

<1> A unique plugin identifier, that can be accessed throughout the system.
If some plugin already registered with the same alias, it will throw an error.
<2> Package meta information.
<3> Supported configurations for the plugin with default values.
<4> List of valid events which this plugin wants to register with the controller.
Each event name will be prefixed by plugin alias, e.g. `pluginName:event1`.
Listing an event means to register the event in the application.
Any plugin can subscribe or publish that event in the application.
<5> Object of valid actions which this plugin wants to register with the controller.
Each action name will be prefixed by plugin alias, e.g. `pluginName:action1`.
Source plugin can define the action while others can invoke that action.
<6> Method which will be invoked by the controller to load the plugin.
Make sure all loading logic gets completed during the life cycle of load.
Controller emit an event `app:ready` which you can use to perform some activities which you want to perform when every other plugin is loaded.
<7> Method to be invoked by controller to perform the cleanup.
