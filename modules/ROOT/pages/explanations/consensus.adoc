= Consensus in Lisk
Mona Bärenfänger <mona@lightcurve.io>
:description: This section provides an overview of the main guides in chronological order, together with an example using the 'Hello World' App.
:toc:
:imagesdir: ../../../assets/images
:v_protocol: master

:url_wiki_pos: https://en.wikipedia.org/wiki/Proof_of_stake

:url_guides_forging: guides/node-management/forging.adoc

:url_protocol_blocks_rewards: {v_protocol}@lisk-protocol::blocks.adoc#rewards_and_fees
:url_protocol_dpos: {v_protocol}@lisk-protocol::consensus-algorithm.adoc#dpos
:url_protocol_bft: {v_protocol}@lisk-protocol::consensus-algorithm.adoc#lisk_bft
:url_protocol_delegate_selection: {v_protocol}@lisk-protocol::consensus-algorithm.adoc#delegate_selection
:url_protocol_fork_choice: {v_protocol}@lisk-protocol::consensus-algorithm.adoc#index-fork_choice_rule-1
:url_protocol_punishment: {v_protocol}@lisk-protocol::consensus-algorithm.adoc#punishment
:url_protocol_transactions_pom: {v_protocol}@lisk-protocol::transactions.adoc#pom
:url_protocol_transactions_delegate: {v_protocol}@lisk-protocol::transactions.adoc#delegate
:url_protocol_transactions_unlock: {v_protocol}@lisk-protocol::transactions.adoc#unlock
:url_protocol_transactions_vote: {v_protocol}@lisk-protocol::transactions.adoc#vote

[[dpos]]
== Delegated Proof of Stake (DPoS)

The Lisk SDK bootstraps a blockchain network that is based on the xref:{url_protocol_dpos}[DPoS] consensus algorithm.

DPoS is related to the {url_wiki_pos}[Proof of Stake (PoS)^] consensus algorithm.
In PoS-based blockchains the creator of the next block is chosen via a selection mechanism that is related to the stake that an individual account holds.
In this regard, a higher stake generally means there is an increased chance to forge a new block to the blockchain.

In DPoS based blockchains, the consensus regarding who can forge the next block is reached by users who vote with their stake for other users.

NOTE: The DPoS used by Lisk is in fact more of a middle ground between PoS and DPoS, as it also requires delegates to hold and lock a certain amount of tokens in their account.

In order to receive votes from other users, a user needs to register their account as <<register, delegate>>.

[[forging]]
=== Forging

The process of adding new blocks to a blockchain that uses the PoS or DPoS consensus algorithm is called forging.

In a DPoS system, each account that has an adequate enough balance to send a xref:{url_protocol_transactions_delegate}[register delegate transaction] can <<register,register a new delegate>> on the network.
Delegates need to increase their <<weight,delegate weight>> by receiving votes from other accounts in order to reach forging positions.
Other accounts can <<vote, vote for delegates>> by sending a xref:{url_protocol_transactions_vote}[delegate vote transaction].
As a reward for securing the network, the forging delegates receive the xref:{url_protocol_blocks_rewards}[transaction fees and block rewards] of the forged blocks and their included transactions.

The process of forging consumes a minimal amount of energy and is therefore an extremely *energy-friendly* consensus algorithm as compared to "mining", which is the analog process for blockchains that run with Proof of Work (PoW).

The 101 delegates with the highest <<weight,delegate weight>> and 2 additional standby delegates are selected to forge during a forging round.
During a forging round, delegates forge blocks one after another in a designated order.
The order in which the selected delegates forge new blocks is a random process and is not connected to the delegate weight.

[NOTE]
====
During a forging round, no new calculations are required which makes the process highly efficient.
This technique enables a very energy efficient process of adding new blocks, which allows forging nodes to run even on machines with very limited processing capabilities, such as a Raspberry Pi.
====

....
101(amount of the forging delegates) + 2(random standby delegates) = 103(Number of blocks of a forging round)
....

After a forging round is completed, the delegate selection process starts again and assigns the delegates to their forging positions.

More information about the delegate selection mechanism can be found in the xref:{url_protocol_delegate_selection}[Lisk Protocol].

[[weight]]
==== Delegate weight

The delegate weight is defined as shown below:

....
delegate weight = minimum { 10 * delegate self-vote , sum of all votes for the delegate }
....

Where `delegate self-vote` is the amount the delegate voted for its own account.
Note that the `sum of all votes for the delegate` includes the self-votes.

[[register]]
=== Registering as delegate

All accounts in the network can register as a delegate by sending a delegate registration transaction.

The chosen delegate name has to be unique in the network.
Once an account is registered as a delegate, it is possible for other accounts in the network to vote for this delegate.

.Example: Creating a delegate registration transaction
[source,js]
----
const tx =  new transactions.DelegateTransaction({
    asset:{
        username: 'myDelegateName'
    },
    nonce: '1',
    fee: '1500000000'
});
----

More information about enabling and disabling forging on a node can be found in the xref:{url_guides_forging}[Enable forging giude].

[[vote]]
=== Voting for a delegate

Accounts can vote for delegates by locking tokens in their account.
After unvoting a delegate the locked tokens can be unlocked again through the unlock transaction.

For instance, lets assume you hold an account with a balance of 100 tokens.

You could use only a part of your tokens for voting, but let's assume you want to vote with all 100.
It is of course possible to split your tokens among multiple delegates, or to use all of them to vote for only one delegate.
For example you could use it to vote for 10 delegates with 10 tokens, or alternatively just on one delegate with the full 100 tokens.

In the example below we decide to vote for one delegate with 70 tokens, and for another one with 30 tokens.

.Example: Vote for two delegates
[source,js]
----
const tx = new transactions.VoteTransaction({
    asset:{
        votes: [
            { delegateAddress:'11750255083444888021L', amount: '7000000000'}, <1>
            { delegateAddress:'64373847834494888026L', amount: '3000000000'} <2>
        ]
    }
});
----

<1> Locks 70 tokens and adds 70 tokens delegate weight to the delegate with address `11750255083444888021L`.
<2> Locks 30 tokens and adds 30 tokens delegate weight to the delegate with address `64373847834494888026L`.

[[unlock]]
=== Unvoting delegates and unlocking of tokens

The amount of tokens used for voting is locked and cannot be used for any other transactions.
This includes but is not limited to balance transfers, further voting or fees.

To use those tokens, the account has to submit a xref:{url_protocol_transactions_vote}[delegate vote transaction], with a negative amount (also called “unvote”).
This will start the unlocking procedure and the LSK will be ready for unlocking 2000 blocks later (roughly 5 hours and 30 minutes).

To recover the locked tokens, the account has to submit two transactions.

. First, the tokens have to be unvoted.
This is done with a new `VoteTransaction`, the transaction just needs to contain a negative amount.
The tokens are now in an “unlocking” state.
They have been unvoted but are not usable yet.
+
.Example: Unvote a delegate
[source,js]
----
const tx = new transactions.VoteTransaction({
    asset:{
        votes: [
            { delegateAddress:'64373847834494888026L', amount: '-1500000000'} // 15 tokens can be unlocked in 2000 blocks
        ]
    },
    nonce: '2',
    fee: '250000'
});
----
+
. After a 2000 block period, the tokens can be unlocked.
This is done with a new `UnlockTransaction`.
The xref:{url_protocol_transactions_unlock}[token unlock transaction] specifies which tokens have to be unlocked and added back to the balance.
This mechanism is necessary to allow blocks to be reverted.
Future improvements of the Lisk blockchain (particularly on the database level), could render this unlock transaction unnecessary.
+
[source,js]
----
const tx = new transactions.UnlockTransaction({
    asset:{
        unlockingObjects:[
            { delegateAddress:'64373847834494888026L', amount: '1500000000', unvoteHeight: '1234' }
        ]
    },
    nonce: '3',
    fee: '250000'
});
----

==== An unlock transaction can contain multiple unlock objects

This allows an account to submit multiple delegate votes and recover those tokens with a single unlock transaction.
Of course, all tokens must have been in the unlocking state for at least 2000 blocks for the unlock to be valid.

== BFT

The Byzantine Fault Tolerance (BFT) algorithm ensures that the network can always reach a consensus about the current state of the blockchain.
The main purpose of the BFT consensus algorithm is that for a given height eventually all Lisk nodes agree on the same block.
This is in particular important in the case where there are different valid blocks for the same height, which can occur due to network delays or delegates forging multiple blocks in their designated time slot.

In most cases, the BFT consensus algorithm implemented in the Lisk SDK takes care of these matters and resolves all conflicts automatically, following rules defined in the xref:{url_protocol_bft}[Lisk Protocol - BFT] section.

Furthermore delegates can be punished, if they misbehave in one of the following ways:

They...

* ... perform double forging i.e. having forging actived on multiple node for the same delegate at the same time.
* ... violate the xref:{url_protocol_fork_choice}[fork choice rule].
* ... or they somehow else forge a block with consensus votes that contradict with the Lisk BFT (See xref:{url_protocol_punishment}[Lisk Protocol>BFT: Punishment of Lisk-BFT protocol violations]).

To punish a delegate, a xref:{url_protocol_transactions_pom}[delegate misbehaviour report] needs to be posted to the network.

=== Delegate misbehaviour report

A delegate misbehaviour report transaction can be issued by anyone in the network, who observes a violation of the Lisk BFT consensus algorithm.

A misbehaviour of a delegate is indicated by the `maxHeightPreviouslyForged` property of a block forged by a delegate.
If `maxHeightPreviouslyForged` is not equal to the `height` of the block which was previousely forged by that delegate, this can be reported bby providing both block headers of the delegate, which have contradicting values.

.Report delegate misbehaviour
[source,js]
----
const tx = new transactions.ProofOfMisbehaviorTransaction({
    asset:{
        header1: {
            blockSignature: 'e8b4768a7805bdcef097458e52b4acc5aed9816032504a57a0ae14ede0054bd916ddc0ff93a4baac91048930afde72f0e89a9fd5b07bd98620e3d5558b34b005',
            generatorPublicKey: '7a7f24c061db6a92320ba14323f814c20dbcc811a931ead3ca63c75a4de1b643',
            height: 8938,
            maxHeightPreviouslyForged: 8788,
            maxHeightPrevoted: 8868,
            numberOfTransactions: 0,
            payloadHash: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',
            payloadLength: 0,
            previousBlockId: '9326981395427095175',
            reward: '500000000',
            seedReveal: 'abe2a66d7a35fd7b580e977d9f7911ae',
            timestamp: 122329567,
            totalAmount: '0',
            totalFee: '0',
            version: 2
        },
        header2: {
            blockSignature: '31ccf4ce1a3a224a2a32c3f4bdc6fad0ddb8feb45b05b7d411eee1a608f9d91284d09c727bba173c882d5dc90cb951c5affc10462d650031a627e00d919cbf08',
            generatorPublicKey: '7a7f24c061db6a92320ba14323f814c20dbcc811a931ead3ca63c75a4de1b643',
            height: 8933,
            maxHeightPreviouslyForged: 8788,
            maxHeightPrevoted: 8868,
            numberOfTransactions: 0,
            payloadHash: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',
            payloadLength: 0,
            previousBlockId: '9326981395427095175',
            reward: '500000000',
            seedReveal: 'abe2a66d7a35fd7b580e977d9f7911ae',
            timestamp: 122329567,
            totalAmount: '0',
            totalFee: '0',
            version: 2
        }
    }
});
----






