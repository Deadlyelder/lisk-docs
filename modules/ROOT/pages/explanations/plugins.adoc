= Lisk plugins
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc: preamble
:v_core: 3.0.0
:imagesdir: ../../assets/images
// Project URLs
:url_references_framework_baseplugin: references/lisk-framework/index.adoc#the-baseplugin
:url_references_framework_actions: references/lisk-framework/index.adoc#application-actions

== When to create a plugin

The Custom plugin is used to provide features to provide...

* a function to aggregate the blockchain data.
* automation to the blockchain logic, such as automatically seeding transactions.
* search capabilities for the blockchain data.
* proxy to the application interfaces.

== Plugin interface

All custom plugins must extend BasePlugin exposed by SDK.
All plugins and the application can interact with each other by using a channel.
Each plugin is given one channel through the “load” function as shown below.

== How to create a custom plugin

The interface for the `BasePlugin` is described in the xref:{url_references_framework_baseplugin}[Lisk Framework reference].

[source,typescript]
----
export class MyPlugin extends BasePlugin {
    static get alias(){ return 'pluginAlias'; }, <1>

    static get info(){ <2>
        return {
            author: '',
            version: '',
            name: '',
        };
    },

    private _knownTimestamps: number[] = []; <3>

    async load(channel: Channel): Promise<void> { <4>
      // initialize plugin
      if (this.options.enable) {
        return false;
      }
      channel.subscribe('app:block:new', ({ data }) => {
        const decodedBlock = this.codec.decodeBlock(data.block);
        this.knownTimestamp.push(decodedBlock.header.timestamp);
        channel.publish('timestamp', { timestamp: decodedBlock.header.timestamp });
      });
    }

    get defaults() { <5>
      return {
        type: 'object',
        properties: {
          enable: {
            type: 'boolean',
          }
        },
      }
    }

    get events() { <6>
      return ['timestamp'];
    }

    get actions() { <7>
        return {
           getKnownTimestamp: () => this._knownTimestamps;
        }
    }

    async unload() { <8>
      this._knownTimestamps = [];
    }
};

----

<1> description
<2> description
<3> description
<4> description
<5> description
<6> description
<7> description
<8> description

== How to invoke actions

A custom plugin will be given a `channel` to communicate with the application.
All xref:{url_references_framework_actions}[application actions] can be invoked through this channel.
Additionally, actions defined in the registered modules and plugins can be called.

[source,typescript]
----
const { data } = await channel.invoke('app:getSchema'); <1>
const { data } = await channel.invoke('pluginAlias:newAction'); <2>
const { data } = await channel.invoke('moduleAlias:anotherAction'); <3>
----

<1> How to call a default application action.
<2> How to call a plugin action
<3> How to call a module action

== How to publish and subscribe to events

Events can be published and subscribed through the `channel`.

[source,typescript]
----
channel.publish('pluginAlias:newEvent', { info: 'sample' }); <1>
channel.subscribe('pluginAlias:newEvent', ({ data }) => { <2>
  console.log(data.info);
});

----

<1> Publish an event
<2> Subscribe to an event
