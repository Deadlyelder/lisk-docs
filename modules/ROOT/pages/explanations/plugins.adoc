= Lisk plugins
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc:
:v_core: 3.0.0
:imagesdir: ../../assets/images
//External URLs
:url_github_httpapi: https://github.com/LiskHQ/lisk-sdk/tree/v5.0.0-alpha.3/framework-plugins/lisk-framework-http-api-plugin
// Project URLs
:url_references_config: references/config.adoc
:url_references_framework_baseplugin: references/lisk-framework/index.adoc#the-baseplugin
:url_references_framework_actions: references/lisk-framework/index.adoc#application-actions

== When to create a plugin

The Custom plugin is used to provide features to provide...

* a function to aggregate the blockchain data.
* automation to the blockchain logic, such as automatically seeding transactions.
* search capabilities for the blockchain data.
* proxy to the application interfaces.

== Default plugins

[cols="30,70",options="header",stripes="hover"]
|===
|Name
|Description

|{url_github_httpapi}[HTTP API^]
a|
Description
|===

== How to create a custom plugin

All custom plugins must extend `BasePlugin` exposed by SDK.
The interface for the `BasePlugin` is described in the xref:{url_references_framework_baseplugin}[Lisk Framework reference].
Plugins and the application can interact with each other by using a channel.
Each plugin is given one channel through the `load` function as shown below.

[source,typescript]
----
export class MyPlugin extends BasePlugin {
    static get alias(){ return 'pluginAlias'; }, <1>

    static get info(){ <2>
        return {
            author: '',
            version: '',
            name: '',
        };
    },

    private _knownTimestamps: number[] = [];

    get defaults() { <3>
      return {
        type: 'object',
        properties: {
          enable: {
            type: 'boolean',
          }
        },
      }
    }

    get events() { <4>
      return ['timestamp'];
    }

    get actions() { <5>
        return {
           getKnownTimestamps: () => this._knownTimestamps;
        }
    }

    async load(channel: Channel): Promise<void> { <6>
      // initialize plugin
      if (!this.options.enable) { <7>
        return;
      }
      channel.subscribe('app:block:new', ({ data }) => { <8>
        const decodedBlock = this.codec.decodeBlock(data.block); <9>
        this._knownTimestamps.push(decodedBlock.header.timestamp); <10>
        channel.publish('timestamp', { timestamp: decodedBlock.header.timestamp }); <11>
      });
    }

    async unload() { <12>
      this._knownTimestamps = [];
    }
};
----

<1> The unique plugin identifier for this plugin is `pluginAlias`
<2> Package meta information.
<3> The configuration schema for this plugin.
After registering the plugin with the application, it can be configured in the xref:{url_references_config}[application configuration].
<4> The plugin registers the event `pluginAlias:timestamp` with the application.
Other plugins and modules can subscribe to this event.
<5> Defines the action `pluginAlias:getKnownTimestamp`, which can be invoked by other plugins and modules in the application.
<6> Method which will be invoked by the controller to load the plugin.
<7> Doesn't load the plugin, if it is disabled in the config.
<8> Subscribes to the event `app:block:new`.
For every new block that is forged, it will perform the following commands.
<9> Decodes the received Block
<10> Pushes the timestamp of the new block into the `_knownTimestamps` array.
<11> Publishes a new event `pluginAlias:timestamp` with the latest block timestamp to the application.
<12> Method to be invoked by controller to perform the cleanup.
Deletes all timestamps in the `_knownTimestamps` array.


