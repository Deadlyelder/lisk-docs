= Lisk modules
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc:
:v_core: 3.0.0
:imagesdir: ../../assets/images
//External URLs
:url_github_dpos: https://github.com/LiskHQ/lisk-sdk/tree/v5.0.0-alpha.3/framework/src/modules/dpos
:url_github_keys: https://github.com/LiskHQ/lisk-sdk/tree/v5.0.0-alpha.3/framework/src/modules/keys
:url_github_sequence: https://github.com/LiskHQ/lisk-sdk/tree/v5.0.0-alpha.3/framework/src/modules/sequence
:url_github_token: https://github.com/LiskHQ/lisk-sdk/tree/v5.0.0-alpha.3/framework/src/modules/token
// Project URLs
:url_references_framework_basemodule: references/lisk-framework/index.adoc#the-basemodule
:url_references_framework_baseasset: references/lisk-framework/index.adoc#the-baseasset

== What is a custom module and a custom asset?

Custom modules bundle block processing logic and transaction processing logic together with a specific account schema.
Each custom module is separated based on the domain and data which the account schema contains.

They are responsible for the state machine part of the blockchain logic.
The state machine validates and updates the information on either account state or chain state.
Those state changes can be introduced through a block header or a transaction.

Each custom module defines its own data.
If a module is required to interact with other data which is managed by another module, it should communicate through the functions exposed by other modules.

== When to create a custom module / custom asset

The Custom module and custom asset are used to provide features to...

* define data stored in blockchain
* define data sent through transaction asset
* define logic which is executed per block
* define logic which is executed per transaction
* define logic which is executed per asset

Also, all of the logic implemented using a custom module / asset must be “deterministic” and executable within block time.

== Default modules

[cols="30,70",options="header",stripes="hover"]
|===
|Name
|Description

|{url_github_dpos}[DPoS module^]
a|
The DPoS module is responsible for handling all DPoS related logics.
Specifically:

* Snapshotting vote weights
* Calculating productivity
* Handling registerDelegate, voteDelegate, unlockToken and reportDelegateMisbehavior transaction assets
* Setting the next delegates set

|{url_github_keys}[Keys module^]
a|
The Keys module handles all logic related to the signatures.

It should verify the signatures based on the multi-signature rules including non-multi-signature accounts.
It also handles the registration of multi-signature accounts.


|{url_github_sequence}[Sequence module^]
a|
The Sequence module handles all logic related to nonce.

It should verify the nonce for all transactions and increment if valid.

|{url_github_token}[Token module^]
a|
The Token module handles all logic related to balance.
Specifically:

* Validating and subtracting fees for all transactions
* Checking the minimum remaining balance requirement
* Giving block rewards to the block generator
* Transferring account balances
|===

== Life cycle of a block

. Receive block
. Apply fork choice rule
. Validate block
.. Validate transactions
... Validate transaction
... *Validate transaction asset*
. Verify block header
. Before block apply
. *Apply block*
.. Apply transactions
... *beforeTransactionApply*
... *Apply asset*
... *afterTransactionApply*
. *After block apply*
. Save block and updated states

The *bold* steps are the steps exposed through the base module and base asset.

== How to create custom module with a custom asset

The custom module and asset must extend the base module and base asset defined in the Lisk SDK.

The interfaces for `BaseModule` and `BaseAsset` are described in the xref:{url_references_framework_basemodule}[Lisk Framework reference].

For a custom asset, the following properties are required:

* `name` is used for UI purpose.
* `id` is used for `AssetID` to send a transaction.
* `schema` defines `asset` schema in a transaction.
* `apply` defines a state change induced by this asset.

.custom_asset.ts
[source,typescript]
----
interface Asset {
  Data: string;
}
export class CustomAsset extends BaseAsset {
  name = 'executeCustomAsset';
  id = 0;
  schema = {
    $id: '/customAsset',
    type: 'object',
    properties: {
      hello: {
        dataType: 'string',
        fieldNumber: 1,
      },
    },
  };

  validate(asset: K): void {
		if (!asset.hello || typeof asset.hello !== 'string' || asset.hello.length > 64) {
			throw new InvalidTransactionError(
                'Invalid "asset.hello" defined on transaction',
                asset.id,
                '.asset.hello',
                asset.hello,
                'A string value no longer than 64 characters',
            );
		}
  };

  async apply({ asset, stateStore, reducerHandler, transaction }) {
    const senderAddress = transaction.senderAddress;
    const senderAccount = await stateStore.account.get(senderAddress);

    if (senderAccount.asset && senderAccount.asset.hello) {
        throw new InvalidTransactionError(
            'You cannot send a hello transaction multiple times',
            transaction.id
        );
    } else {
        sender.asset = { hello: this.asset.hello };
        store.account.set(sender.address, sender);
    }

    const senderBalance = await reducerHandler.invoke("token:getBalance", {
      address: senderAddress,
    });
    const minRemainingBalance = await reducerHandler.invoke(
      "token:getMinRemainingBalance"
    );

    if (asset.initValue < minRemainingBalance) {
      throw new Error("NFT init value is too low.");
    }

    if (senderBalance < asset.initValue + minRemainingBalance) {
      throw new Error("Sender balance is not enough to create an NFT");
    }

    const nftToken = createNFTToken({
      ownerAddress: senderAddress,
      nonce: transaction.nonce,
      value: asset.initValue,
      minPurchaseMargin: asset.minPurchaseMargin,
    });

    senderAccount.nft.ownNFTs.push(nftToken.id);
    await stateStore.account.set(senderAddress, senderAccount);

    await reducerHandler.invoke("token:debit", {
      address: senderAddress,
      amount: asset.initValue,
    });

    const allTokens = await getAllNFTTokens(stateStore);
    allTokens.push(nftToken);
    await setAllNFTTokens(stateStore, allTokens);
  }
}
----

For a custom module, the following properties are required:

* `name` will be used for a key for the account schema if defined.
* `id` will be used for a fieldNumber for the account schema, and for a `moduleID` to send a transaction with `CustomAsset`.

.custom_module.ts
[source,typescript]
----
import { CustomAsset } from './custom_asset';
import {
	TransactionApplyContext,
	AfterBlockApplyContext,
	BeforeBlockApplyContext,
	AfterGenesisBlockApplyContext,
} from '../types';

export class CustomModule extends BaseModule {
  name = 'customModule';
  id = 1001;
  accountSchema = {
    type: 'object',
    properties: {
      latestData: {
        fieldNumber: 1,
        dataType: 'string',
      },
    },
    default: {
      latestData: 'initial data',
    },
  };
  transactionAssets: [new CustomAsset()];
  actions = {
    someAction: async () => {
        return this.id
    },
  };
  events = ['someEvent','anotherEvent'];
  reducers = {};
  beforeTransactionApply(context: TransactionApplyContext): Promise<void> {
    // Code in here is applied before a transaction is applied.
    this._channel.publish();
  };
  afterTransactionApply(context: TransactionApplyContext): Promise<void> {
    // Code in here is applied after a transaction is applied.
  };
  afterGenesisBlockApply(context: AfterGenesisBlockApplyContext): Promise<void> {
    // Code in here is applied after a genesis block is applied.
  };
  beforeBlockApply(context: BeforeBlockApplyContext): Promise<void> {
    // Code in here is applied before a block is applied.
  }
  afterBlockApply(context: AfterBlockApplyContext): Promise<void> {
    // Code in here is applied after a block is applied.
  }
}
----
