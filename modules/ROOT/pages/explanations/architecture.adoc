= Architecture
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:page-aliases: lisk-framework/index.adoc
:toc: preamble
:v_core: 3.0.0
:imagesdir: ../../assets/images
// Project URLs
:url_explanations_modules: explanations/modules.adoc
:url_explanations_plugins: explanations/plugins.adoc
:url_guides_config: guides/app-development/configuration.adoc
:url_references_config: references/config.adoc

image:banner_framework.png[Logo]

== The Lisk Framework

The Lisk Framework is an application framework which integrates the Lisk Elements packages in order to form a functioning Lisk blockchain application.
Its modular architecture allows developers to extend the off-chain and on-chain logic with user defined plugins and modules.

The Lisk Framework provides a consistent and intuitive interface between each module and plugin.

== Architecture overview

The diagram shown below provides a high-level overview of the architecture:

image:diagram_framework.png[Logo]

The framework is constructed by the following components:

<<Application>>:: The application is an entry point and manages the controller and the node.

[[off-chain-architecture]]
=== Off-chain architecture
Controller:: Handles the setup and teardown of channels and plugins.
Also, it is responsible for the communication between the plugins and the application.
xref:{url_explanations_plugins}[Plugins]:: Applications which interact with the node through RPC channels to expose information from the node outside the context of the blockchain itself.

[[on-chain-architecture]]
=== On-chain architecture
Node:: The main object in charge of acting on the blockchain including:
* forging blocks
* synchronising with the network
* processing blocks from the network
* ... and broadcasting blocks and transactions to the network.
xref:{url_explanations_modules}[Modules]:: Objects injected into the node with a single responsibility related to the blockchain state.

== Application

The `Application` class is an entry point to create a blockchain application.
It can be instantiated in two ways:

[source,js]
----
//Initiates the Application including all default modules
const app = Application.defaultApplication(genesisBlock, config);
//Initiates the Application without default modules
const app = new Application(genesisBlock, config);
----

`genesisBlock` represents the <<genesis-block>> and `config` represents the application <<configuration>>.

[TIP]
The recommended way to create an `Application` instance, is to use `defaultApplication` since it comes with the default modules.
If the class constructor is used, the modules need to be registered manually.

=== Registering modules and plugins

In order to register an additional module below function should be used.

[source,js]
----
app.registerModule(CustomModule);
----

Additionally, any plugin may be registered with the below function.

[source,js]
----
app.registerPlugin(CustomPlugin);
----

== Genesis block

A genesis block must be given to the application, and all networks should have different genesis block.

.Genesis block schema
[source,js]
----
const genesisBlock = {
  header: {
    generatorPublicKey: "",
    // height can be either 0 or regenesis height
    height: number,
    // empty buffer or merkle root of the previous blocks from previous network
    previousBlockID: Buffer,
    reward: 0n,
    signature: "",
    // timestamp of the blockchain in unix timestamp in second
    timestamp: number,
    // transactionRoot is alway empty hash
    transactionRoot: Buffer.from('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', 'hex'),
    version: 0,
    asset: {
      // number of initial round to use the initDelegates
      initRounds: number,
      // address of initial delegates
      initDelegates: Buffer[],
      // encoded accounts for the initial state
      accounts: Buffer[],
    },
  },
  payload: [],
}
----

//TODO: add link to genesis block creation guide
TIP: A valid genesis block can be created using @liskhq/lisk-genesis as described here.

=== Configuration

The application config object is passed to the `Application` and must follow the  xref:{url_references_config}[] schema.

For more information about how to configure your blockchain application, check out the guide xref:{url_guides_config}[].

== Action and event interfaces

The Lisk Framework defines actions and events which can be invoked and subscribed through a channel.

All modules and plugins will be given a `channel` to communicate with the application via actions and events.

=== How to invoke actions

<<application-actions>> can be invoked through the `channel`.
Additionally, all actions defined in modules and plugins can be called by every module an plugin in the application.

[source,typescript]
----
const { data } = await channel.invoke('app:getSchema'); <1>
const { data } = await channel.invoke('pluginAlias:getKnownTimestamps'); <2>
const { data } = await channel.invoke('moduleAlias:anotherAction'); <3>
const { data }= await channel.invoke('app:actionName', input); <4>
----

<1> How to invoke a default application action.
<2> How to invoke a plugin action.
<3> How to invoke a module action.
<4> Hot to invoke an action that needs some input.

=== How to publish and subscribe to events

<<application-events>> can be subscribed and published through the `channel`.
Additionally, all events defined in modules / plugins can be subscribed by every other module and plugin in the application.

[source,typescript]
----
channel.publish('pluginAlias:timestamp', { info: 'sample' }); <1>
channel.subscribe('pluginAlias:timestamp', ({ data }) => { <2>
  console.log(data.info);
});
----

<1> How to publish an event
<2> How to subscribe to an event

=== Application actions

[cols=",,",options="header",stripes="hover"]
|===
|Name
|Inputs
|Description

|`app:getConnectedPeers`
| none
|Returns all connected peers.

|`app:getDisconnectedPeers`
| none
|Returns all disconnected peers

|`app:getForgers`
| none
|Returns the status of all registered forgers information for current round

|`app:updateForgingStatus`
a|
[source,typescript]
----
{
address: string; <1>
password: string; <2>
forging: boolean; <3>
}
----
<1> binary address in hex string
<2> password to decrypt the passphrase
<3> when enabling forging, the value should be `true`
|Enable or disable forging for a registered forger in config

|`app:getForgingStatus`
| none
|Description

|`app:getTransactionsFromPool`
| none
|Description

|`app:postTransaction`
a|
[source,typescript]
----
{
  transaction: string; <1>
}
----
<1> encoded transaction in hex string
|Description

|`app:getLastBlock`
| none
|Description

|`app:getAccount`
a|
[source,typescript]
----
{
  address: string; <1>
}
----
<1> address in hex string
|Description

|`app:getAccounts`
a|
[source,typescript]
----
{
  address: string[]; <1>
}
----
<1> address in hex string
|Description

|`app:getBlockByID`
a|
[source,typescript]
----
{
  id: string; <1>
}
----
<1> block ID in hex string
|Description

|`app:getBlocksByIDs`
a|
[source,typescript]
----
{
  ids: string[]; <1>
}
----
<1> block ID in hex string
|Description

|`app:getBlockByHeight`
a|
[source,typescript]
----
{
  height: number; <1>
}
----
<1> block height
|Description

|`app:getBlocksByHeightBetween`
a|
[source,typescript]
----
{
  from: number; <1>
  to: number; <2>
}
----
<1> block height to fetch from
<2> block height to fetch to
|Description
|`app:getTransactionByID`
a|
[source,typescript]
----
{
  ids: string; <1>
}
----
<1> transaction ID in hex string
|Description
|`app:getTransactionsByIDs`
a|
[source,typescript]
----
{
  ids: string[]; <1>
}
----
<1> transaction ID in hex string
|Description
|`app:getSchema`
| none
|Description
|`app:getRegisteredModules`
| none
|Description
|`app:getNodeInfo`
| none
|Description
|===

=== Application events

* `app:ready` - Fired when the application starts
* `app:shutdown` - Fired when application stops
* `app:network:ready` - Fired when network has at least one outbound connection
* `app:network:event` - Fired when application receives P2P event from the network
* `app:transaction:new` - Fired when the node receives a new transaction
* `app:chain:fork` - Fired when the node received a block from forked chain
* `app:chain:validators:change` - Fired when node updates validator set
* `app:block:new` - Fired when a new block is added to the blockchain
* `app:block:delete` - Emitted when a block is deleted from blockchain




