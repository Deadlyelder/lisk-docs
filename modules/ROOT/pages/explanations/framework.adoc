= Lisk Framework
Mona Bärenfänger <mona@lightcurve.io>
:description: The Lisk Framework overview provides a high-level synopsis of the Lisk Framework architecture, including its modules and components, how they communicate, and also how to change the default configuration.
:page-aliases: lisk-framework/index.adoc
:toc: preamble
:v_core: 3.0.0
:imagesdir: ../../assets/images
:page-no-next: true
:page-previous: /lisk-sdk/references/lisk-elements/index.html
:page-previous-title: Lisk Elements

:url_github_lip05: https://github.com/LiskHQ/lips/blob/master/proposals/lip-0005.md
:url_github_lip11: https://github.com/LiskHQ/lips/blob/master/proposals/lip-0011.md

:url_reference_config: references/config.adoc

:url_core_reference_config: {v_core}@lisk-core::reference/config.adoc
:url_guides_config: guides/app-development/configuration.adoc

image:banner_framework.png[Logo]

== What is the Lisk Framework?

The Lisk Framework is an application framework responsible for establishing and maintaining the interactions between the modules of a Lisk blockchain application.

The Lisk Framework aims to provide a consistent and intuitive interface between each module and plugin.

== Architecture overview

The diagram shown below provides a high-level overview of the architecture:

image:diagram_framework.png[Logo]

The framework is constructed by the following components:

<<Application>>:: The application is an entry point and manages the controller and the node.
Controller:: Handles the setup and teardown of channels and plugins.
Also, it is responsible for the communication between the plugins and the application.
Node:: The main object in charge of acting on the blockchain including:
* forging blocks
* synchronising with the network
* processing blocks from the network
* ... and broadcasting blocks and transactions to the network.
Modules:: Objects injected into the node with a single responsibility related to the blockchain state.
Example: The “token” module is responsible for everything related to account balances.
Plugins:: Applications which interact with the node through RPC channels to expose information from the node outside the context of the blockchain itself.
Example: “HTTPAPI, “plugin” which exposes blockchain data through HTTP

The application logic can be configured as desired in the xref:{url_reference_config}[Lisk SDK configuration], see also <<configuration, Configuration of the Lisk Framework".

== Application

The `Application` class is an entry point to create a blockchain application.
`Application` can be instantiated in two ways.

[source,js]
----
//Initiates the Application including all default modules
const app = Application.defaultApplication(genesisBlock, config);
//Initiates the Application without default modules
const app = new Application(genesisBlock, config);
----

`genesisBlock` represents the genesis block and `config` represents the application configuration.

[TIP]
The recommended way is to use `defaultApplication` since it comes with default modules.
If the class constructor is used, the modules need to be added manually.

=== Registering modules and plugins

In order to register an additional module below function should be used.

[source,js]
----
app.registerModule(CustomModule);
----

Additionally, any plugin may be registered with the below function.

[source,js]
----
app.registerPlugin(CustomPlugin);
----

Differences between custom modules and custom plugins are discussed below.


== Modules

Modules are located in the `modules` folder.
They are individual building blocks for the Lisk SDK.

==== Default modules

The default modules are shipped along with the Lisk SDK itself.
These modules constitute the minimum requirements to run a blockchain with the Lisk SDK.

* *API module:* This provides HTTP API endpoints, that enable users and other programs to interact with the Lisk blockchain through the API.

==== Custom modules

NOTE: The implementation of each module is the responsibility of the user, however it must be inherited from the `BaseModule` to implement its methods.

Custom modules can be plugged into the Lisk SDK and may offer new features/capabilities for the application, and replace the default modules functionalities where necessary.
They extend the existing instance with a specific, (and circumscribed) set of features.

[source,js]
----
const BaseModule = require('lisk-framework/src/modules/base_module')

// Exported as main file to javascript package
export default class MyModule extends BaseModule {
    /**
    * @param {Object} options - An object of module options
    */
    constructor(options) { <1>
     super(options);
    }

    /**
    * @return {string} alias - Return the module alias as string.
    * */
    static get alias(){ return 'moduleAlias'; }, <2>

    /**
    * @return {Object} info - JSON object referring the version, module name and module author.
    */
    static get info(){ <3>
        return {
            author: '',
            version: '',
            name: '',
            };
    },

    /**
    * @param {Channel} channel - An instance of a communication channel.
    * @return {Promise<void>}
    */
    async load(channel) {}, <4>


    /**
     * @return {Object} defaults - JSON object with default options for the module.
     */
    get defaults() { return {}; }, <5>

    /**
     * @return {Array} events - String Array of events.
     */
    get events() { return []; }, <6>

    /**
     * @return {Object} actions - Contains all available action names as key, and the corresponding function as value.
     */
    get actions() { <7>
        return {
            action1: action => {},
        }
    },

    /**
     * @return {Promise<void>}
     */
    async unload() {}, <8>
};
----

<1> Constructor of the module.
<2> Required.
A unique module identifier, that can be accessed throughout the system.
If a module is already registered with the same alias, it will throw an error.
<3> Required.
Package meta information.
<4> Required.
Method which will be invoked by the controller to load the module.
Ensure all loading logic is completed during the life cycle of load.
The controller emits an event, `lisk:ready` which can be used to perform certain activities, which may be required to be performed when all the other modules are loaded.
<5> Supported configurations for the module with default values.
<6> List of valid events which this module wants to register with the controller.
Each event name will be prefixed by a module alias, e.g. moduleName:event1. Listing an event means to register the event in the application.
Any module can subscribe or publish that event in the application.
<7> Object of valid actions which this module wants to register with the controller.
Each action name will be prefixed by a module alias, e.g. moduleName:action1. The source module can define the action whilst the others can invoke that action.
<8> Method to be invoked by the controller to perform the cleanup.

==== Module communication

Modules communicate with each other through event-based <<channels,channels>>.
Modules running in different processes communicate with each other over IPC channels.

By default, modules will run in the same process as the controller, which loads the module.
To load a module in a child process, ensure the `ipc` is enabled in the xref:{url_reference_config}[config] and set the environment variable `LISK_CHILD_PROCESS_MODULES` with the module alias.

TIP: If the respective module is using a high amount of CPU power, loading a module in a child process can prevent CPU usage bottlenecks.

Multiple modules can be defined by using commas, as shown below: `LISK_CHILD_PROCESS_MODULES=httpApi,chain`.

