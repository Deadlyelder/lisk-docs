= Lisk Framework
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:page-aliases: lisk-framework/index.adoc
:toc: preamble
:v_core: 3.0.0
:imagesdir: ../../assets/images
// Project URLs
:url_explanations_modules: explanations/modules.adoc
:url_explanations_plugins: explanations/plugins.adoc
:url_guides_config: guides/app-development/configuration.adoc
:url_references_config: references/config.adoc

image:banner_framework.png[Logo]

== What is the Lisk Framework?

The Lisk Framework is an application framework which integrates the Lisk Elements libraries in order to form a functioning Lisk blockchain application.
Its modular architecture allows developers to extend the off-chain and on-chain logic with user defined plugins and modules.

The Lisk Framework provides a consistent and intuitive interface between each module and plugin.

== Architecture overview

The diagram shown below provides a high-level overview of the architecture:

image:diagram_framework.png[Logo]

The framework is constructed by the following components:

<<Application>>:: The application is an entry point and manages the controller and the node.
Controller:: Handles the setup and teardown of channels and plugins.
Also, it is responsible for the communication between the plugins and the application.
Node:: The main object in charge of acting on the blockchain including:
* forging blocks
* synchronising with the network
* processing blocks from the network
* ... and broadcasting blocks and transactions to the network.
xref:{url_explanations_modules}[Modules]:: Objects injected into the node with a single responsibility related to the blockchain state.
Example: The “token” module is responsible for everything related to account balances.
xref:{url_explanations_plugins}[Plugins]:: Applications which interact with the node through RPC channels to expose information from the node outside the context of the blockchain itself.
Example: “HTTPAPI, “plugin” which exposes blockchain data through HTTP

== Application

The `Application` class is an entry point to create a blockchain application.
`Application` can be instantiated in two ways.

[source,js]
----
//Initiates the Application including all default modules
const app = Application.defaultApplication(genesisBlock, config);
//Initiates the Application without default modules
const app = new Application(genesisBlock, config);
----

`genesisBlock` represents the <<genesis-block>> and `config` represents the application <<configuration>>.

[TIP]
The recommended way is to use `defaultApplication` since it comes with default modules.
If the class constructor is used, the modules need to be added manually.

=== Registering modules and plugins

In order to register an additional module below function should be used.

[source,js]
----
app.registerModule(CustomModule);
----

Additionally, any plugin may be registered with the below function.

[source,js]
----
app.registerPlugin(CustomPlugin);
----

== Genesis block

A genesis block must be given to the application, and all networks should have different genesis block.

.Genesis block schema
[source,js]
----
const genesisBlock = {
  header: {
    generatorPublicKey: "",
    // height can be either 0 or regenesis height
    height: number,
    // empty buffer or merkle root of the previous blocks from previous network
    previousBlockID: Buffer,
    reward: 0n,
    signature: "",
    // timestamp of the blockchain in unix timestamp in second
    timestamp: number,
    // transactionRoot is alway empty hash
    transactionRoot: Buffer.from('e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', 'hex'),
    version: 0,
    asset: {
      // number of initial round to use the initDelegates
      initRounds: number,
      // address of initial delegates
      initDelegates: Buffer[],
      // encoded accounts for the initial state
      accounts: Buffer[],
    },
  },
  payload: [],
}
----

//TODO: add link to genesis block creation guide
TIP: A valid genesis block can be created using @liskhq/lisk-genesis as described here.

=== Configuration

The application config object is passed to the `Application` and must follow the  xref:{url_references_config}[] schema.

For more information about how to configure your blockchain application, check out the guide xref:{url_guides_config}[].

== Action and event interfaces

The Lisk Framework defines actions and events which can be invoked and subscribed through a channel.

Action and Events can be used as below.

[source,js]
----
// action invoke
const { data }= await channel.invoke('actionName', input);
// event subscribe
channel.subscribe('eventName', ({ data }) => {});
----

=== Application actions

[cols=",,",options="header",stripes="hover"]
|===
|Name
|Inputs
|Description

|`app:getConnectedPeers`
| none
|Returns all connected peers.

|`app:getDisconnectedPeers`
| none
|Returns all disconnected peers

|`app:getForgers`
| none
|Returns the status of all registered forgers information for current round

|`app:updateForgingStatus`
a|
[source,typescript]
----
{
address: string; <1>
password: string; <2>
forging: boolean; <3>
}
----
<1> binary address in hex string
<2> password to decrypt the passphrase
<3> when enabling forging, the value should be true
|Enable or disable forging for a registered forger in config

|`app:getForgingStatus`
| none
|Description

|`app:getTransactionsFromPool`
| none
|Description

|`app:postTransaction`
a|
[source,typescript]
----
{
  transaction: string; <1>
}
----
<1> encoded transaction in hex string
|Description

|`app:getLastBlock`
| none
|Description

|`app:getAccount`
a|
[source,typescript]
----
{
  address: string; <1>
}
----
<1> address in hex string
|Description

|`app:getAccounts`
a|
[source,typescript]
----
{
  address: string[]; <1>
}
----
<1> address in hex string
|Description

|`app:getBlockByID`
a|
[source,typescript]
----
{
  id: string; <1>
}
----
<1> block ID in hex string
|Description

|`app:getBlocksByIDs`
a|
[source,typescript]
----
{
  ids: string[]; <1>
}
----
<1> block ID in hex string
|Description

|`app:getBlockByHeight`
a|
[source,typescript]
----
{
  height: number; <1>
}
----
<1> block height
|Description

|`app:getBlocksByHeightBetween`
a|
[source,typescript]
----
{
  from: number; <1>
  to: number; <2>
}
----
<1> block height to fetch from
<2> block height to fetch to
|Description
|`app:getTransactionByID`
a|
[source,typescript]
----
{
  ids: string; <1>
}
----
<1> transaction ID in hex string
|Description
|`app:getTransactionsByIDs`
a|
[source,typescript]
----
{
  ids: string[]; <1>
}
----
<1> transaction ID in hex string
|Description
|`app:getSchema`
| none
|Description
|`app:getRegisteredModules`
| none
|Description
|`app:getNodeInfo`
| none
|Description
|===

=== Application events

* `app:ready` - Fired when the application starts
* `app:shutdown` - Fired when application stops
* `app:network:ready` - Fired when network has at least one outbound connection
* `app:network:event` - Fired when application receives P2P event from the network
* `app:transaction:new` - Fired when the node receives a new transaction
* `app:chain:fork` - Fired when the node received a block from forked chain
* `app:chain:validators:change` - Fired when node updates validator set
* `app:block:new` - Fired when a new block is added to the blockchain
* `app:block:delete` - Emitted when a block is deleted from blockchain




