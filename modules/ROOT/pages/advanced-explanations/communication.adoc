= Communication
Mona Bärenfänger <mona@lightcurve.io>
:description: Introduces the Lisk communication architecture, which is based on IPC Unix Sockets and WebSocket.
//Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
//External URLs
:url_npm_lisk_sdk: https://www.npmjs.com/package/lisk-sdk
:url_ipc_socket: https://en.wikipedia.org/wiki/Unix_domain_socket
:url_websocket: https://en.wikipedia.org/wiki/WebSocket
// Project URLs
:url_architecture_communication: advanced-explanations/communication.adoc
:url_guides_config: guides/app-development/configuration.adoc
:url_references_elements_client: references/lisk-elements/client.adoc
:url_architecture: advanced-explanations/architecture.adoc#application
:url_rpc_endpoints: advanced-explanations/rpc-endpoints.adoc
:url_guides_api_access: guides/node-management/api-access.adoc
:url_rpc_actions: advanced-explanations/rpc-endpoints.adoc#application-actions
:url_rpc_events: advanced-explanations/rpc-endpoints.adoc#application-events
:url_elements_apiclient: references/lisk-elements/api-client.adoc
:url_intro_modules_lifecycle: introduction/modules.adoc#lifecycle-hooks

//TODO: Update communication page

The Lisk SDK communicates via <<actions>>, <<reducers>> and <<events>> which can be invoked(actions,reducers) or subscribed(events) to.

The open Lisk communication architecture is based on {url_ipc_socket}[IPC Unix Sockets^] and {url_websocket}[WebSocket (WS)^].
The xref:{url_architecture}[Application] can be configured to either expose an IPC or a WS API that can be used by internal components such as modules and plugins, as well as by any external service like other scripts in JS, a tool in Rust, or a Python daemon.
The Lisk SDK offers two different RPC API modes: `ipc` (Inter-process communication) and `ws` (WebSocket).
If the node and the frontend are running on the same machine, it is recommended to use the `ipc` mode.
To enable the API to be reachable from remote, use the `ws` option.

TIP: For more information about the configuration of the RPC endpoints, check out the xref:{url_guides_config}[configuration guide].

image::communication-architecture.png[]

== Interfaces

image::intro/sdk-interfaces.png[]

[[the-api-client]]
== The API client (external communication)

The xref:{url_elements_apiclient}[] simplifies to send API requests to a blockchain application via IPC or WS.

It can be imported in any JS client application.

It  provides an interface to *subscribe* to all events and to *invoke* actions of the blockchain application and its' modules & plugins.

TIP: To conveniently communicate with a blockchain application, use the `apiClient` which is included in the xref:{url_references_elements_client}[@liskhq/lisk-client] and the {url_npm_lisk_sdk}[lisk-sdk^] packages.

[tabs]

=====
WS API client example::
+
--
[source,js]
----
const { createIPCClient, createWSClient } = require('@liskhq/lisk-client');
let clientCache;

const getClient = async () => {
  if (!clientCache) {
    clientCache = await createWSClient('ws://localhost:8080/ws');
  }
  return clientCache;
};

const useClient = async () => {
  const client = await getClient();
  const blockAtHeight123 = await client.block.getByHeight(123);
  client.subscribe('app:block:new', ( data ) => {
    console.log("new block:",data);
  });
  return blockAtHeight123;
};

useClient().then((val) => {
  console.log("val:",val);
});
----
--
IPC API client example::
+
--
[source,js]
----
const { apiClient } = require('lisk-sdk');
let clientCache;

const getClient = async () => {
    if (!clientCache) {
        clientCache = await apiClient.createIPCClient('~/.lisk/my-app');
    }
    return clientCache;
};

const useClient = async () => {
  const client = await getClient();
  const blockAtHeight123 = await client.block.getByHeight(123);
  client.subscribe('app:block:new', ( data ) => {
    console.log("new block:",data);
  });
  return blockAtHeight123;
};

useClient().then((val) => {
  console.log("val:",val);
});
----
--
=====

== Channels (internal communication)

All modules and plugins will be given a `channel` to communicate with the application via actions and events.

=== Channel for modules

The channel is used inside of the xref:{url_intro_modules_lifecycle}[lifecycle hooks] of a module to publish events to the application.

The following function is available for a `channel` inside a module:

* `publish(eventName: string, data?: object)`: Publishes an event.

[source,js]
----
this._channel.publish('hello:newHello', {
  sender: transaction._senderAddress.toString('hex'),
  hello: helloAsset.helloString
});
----

=== Channel for plugins

The channel is used inside of the xref:{url_intro_modules_lifecycle}[load() and unload()] functions of a plugin.

The following function is available for a `channel` inside a plugin:

* `publish(eventName: string, data?: object)`: Publishes an event.
* `subscribe(eventName: string, cb: EventCallback)`: Subscribes to an event.
* `invoke(actionName: string, params?: object)`: Invokes an action.

[source,js]
----
channel.subscribe('app:block:new', ({ data }) => {
    const decodedBlock = this.codec.decodeBlock(data.block);
    this._knownTimestamps.push(decodedBlock.header.timestamp);
    channel.publish('myPlugin:timestamp', { timestamp: decodedBlock.header.timestamp });
});
----

== Aliases

<<events>> and <<actions>> are identified by their alias.

Example alias: `"monitor:getTransactionStats"`

The alias always consists of the following parts:

. *Prefix:* Consists of the module or plugin name that provides the respective action or event.
Equals `app` if it's an application event or action.
. *Separator:*
Prefix and suffix are always separated by a colon `:`.
. *Suffix:* The respective name of the event or action.

== Actions

xref:{url_rpc_actions}[actions]

=== How to invoke actions

The first argument is always the alias.
If input data is required, it is provided as second argument.

[tabs]

=====
API client::
+
--
Actions can be invoked by <<the-api-client>>.

.How to invoke different kind of actions with the API client
[source,js]
----
const data = await client.invoke('app:getSchema'); <1>
const data = await client.invoke('app:actionName', input); <2>
client.invoke('monitor:getTransactionStats').then((val) => { <3>
    console.log(val);
});
----

<1> How to invoke an action.
<2> How to invoke an action that needs some input data.
<3> Example of how to invoke an action of the monitor plugin.
--
Channel::
+
--
Actions can be invoked by plugins with the <<channel-for-plugins>>.

.How to invoke an action inside a plugin
[source,js]
----
this._nodeInfo = await this._channel.invoke("app:getNodeInfo");
----
--
=====

== Reducers

IMPORTANT: Reducers are only used and defined inside of modules.

== Events

xref:{url_rpc_events}[Events]

=== How to publish and subscribe to events

Events are published inside lifecycle hooks of the module.
The `channel` is available inside the lifecycle hooks, which allows to subscribe and publish to events, as well as invoking actions in the network.

.Publishing an event
[source,typescript]
----
channel.publish('pluginAlias:timestamp', { info: 'sample' });
----

Subscribe to an event by utilizing <<the-api-client>>.

.Subscribing to an event
[source,typescript]
----
client.subscribe('pluginAlias:timestamp', ( data ) => {
  console.log(data);
});
----

TIP: More information about available events and actions can be found at the xref:{url_rpc_endpoints}[] page.


