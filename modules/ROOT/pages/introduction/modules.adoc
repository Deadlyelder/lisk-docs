= Modules
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
// URLs
:url_github_hello_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/hello-world/blockchain_app/hello_module/hello_module.js
:url_github_nft_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/nft/blockchain_app/nft_module/index.js
:url_github_srs_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/social-recovery/blockchain_app/srs_module/index.js
// Project URLs
:url_advanced_architecture_defaultapp: advanced-explanations/architecture.adoc#application
:url_advanced_architecture_genesisblock: advanced-explanations/architecture.adoc#genesis-block
:url_advanced_architecture_lifecycle: advanced-explanations/architecture.adoc#life-cycle-of-a-block
:url_advanced_communication: advanced-explanations/communication.adoc
:url_advanced_communication_interfaces: advanced-explanations/communication.adoc#interfaces
:url_advanced_communication_alias: advanced-explanations/communication.adoc#alias
:url_advanced_schemas: advanced-explanations/schemas.adoc
:url_intro_bapps_onchain: introduction/blockchain-applications.adoc#on-chain-logic
:url_intro_plugins: introduction/plugins.adoc
:url_guides_setup: guides/app-development/setup.adoc
:url_guides_genesis: guides/app-development/genesis-block.adoc
:url_guides_module: guides/app-development/module.adoc
:url_guides_asset: guides/app-development/asset.adoc
:url_protocol_accounts: protocol:accounts.adoc
:url_references_framework_basemodule: references/lisk-framework/index.adoc#the-basemodule
:url_references_framework_baseasset: references/lisk-framework/index.adoc#the-baseasset
:url_dpos_module: references/lisk-framework/dpos-module.adoc
:url_keys_module: references/lisk-framework/keys-module.adoc
:url_token_module: references/lisk-framework/token-module.adoc
:url_tutorials_hello: tutorials/hello-world.adoc
:url_tutorials_hello_asset: tutorials/hello-world.adoc#the-hello-asset
:url_tutorials_nft: tutorials/nft.adoc
:url_tutorials_srs: tutorials/srs.adoc

Modules hold all logic that is changing the state of the blockchain; or in other words, all logic that makes changes on the blockchain.

Modules can be registered to a blockchain application to extend the xref:{url_intro_bapps_onchain}[on-chain logic].

.When to create a new module
****
Modules enable to...

* define how data is stored on the blockchain
* define logic which is executed per block
* define logic which is executed per transaction
****

[TIP]

====
For a more practical guide, how to create a new module, check out the guide xref:{url_guides_module}[].

If you wish to view an example of a fully implemented module, check out the following examples:

* the {url_github_hello_module}[Hello module] from the xref:{url_tutorials_hello}[] tutorial
* the {url_github_nft_module}[NFT module] from the xref:{url_tutorials_nft}[] tutorial
* the {url_github_srs_module}[SRS module] from the xref:{url_tutorials_srs}[] tutorial
====

== Adding a module to the application

Modules need to be registered to become available in the application.
If the application was xref:{url_guides_setup}[bootstrapped] with Lisk Commander, they are registered in the file `src/app/modules.ts`.

[IMPORTANT]
====
Registering a new module requires the generation of a new genesis block, if the module defines an <<account-schema>>.
This always results in a hardfork of the blockchain of the application.

Check out the xref:{url_guides_genesis}[Generating a genesis block] guide for more information on how to generate a new genesis block for your application.
====

.Example: How to register a module with the application in `modules.ts`
[source,typescript]
----
import { Application } from 'lisk-sdk';
import { SomeModule } from "some-module"; // <1>

export const registerModules = (app: Application): void => {
    app.registerModule(SomeModule); // <2>
};
----

<1> Import the module from an NPM package or from a local path.
<2> Add this line to register the module with the application.

== Module anatomy

All important parts of a module are shown in the below diagram and explained in more detail below.

.Anatomy of a module
image:intro/module-asset.png[]

== The module class

Each module is constructed as a class which extends from the xref:{url_references_framework_basemodule}[BaseModule].

The base module provides an interface which needs to be completed by implementing the below described components of a module.

== Module ID

The module ID is the unique identifier for a module in the application.

The module IDs `0`-`999` are reserved for official modules for the Lisk SDK.
That means, the minimum ID for a new module is `1000`.
The maximum value for a module ID is `2^32 - 1`(equals 4,294,967,295), because it is stored as `uint32` value.

It is also important to note, that module IDs do not need to be in succession, the only requirement is, that they are unique within the blockchain application.
So as an example, it is valid to register multiple modules to the application which have the following module IDs: `1003`, `1000`, `2500001` because they are in the allowed number range, and each ID is different.

== Module name

The module name is the human readable unique identifier for the module.

It is used as prefix in the xref:{url_advanced_communication_alias}[alias] of events and actions, and as key label to to add the properties of the <<account-schema>> to the user accounts.

== Logger

The logger is accessible inside of a module under `this._logger`.
As the name suggests, the logger enables to create log messages for the module for the different log levels:

* trace
* debug
* info
* warn
* error
* fatal

[source,js]
----
this._logger.debug(nextRound, 'Updating delegate list for');
----

The logger expects 2 arguments:

. data of the log message (object)
. message of the log message (string)

== Interfaces
Modules can expose interfaces (<<actions>>, <<events>> and <<reducers>>), which allow other components of the application to interact with the module.

Actions and Events are exposed to xref:{url_intro_plugins}[] and to external services.

Reducers can only be invoked by other modules of the application.

TIP: View the "Interfaces" section of the xref:{url_advanced_communication_interfaces}[Communication] page to see an overview about the different interfaces and their accessibility in modules, plugins and external services.

=== Actions

Actions are functions which can be invoked via Remote-Procedure-Calls (RPC) by plugins and external services, to request data from the module.

=== Events

Events are published by the module on relevant occasions.
Plugins and external services can subscribe to these events and as a result, they will be notified every time a new event is published.

=== dataAccess

Use the property `this._dataAccess` to get data from the blockchain in the module.

[TIP]
Updating and changing of data on the blockchain is only allowed inside of <<assets>> and <<lifecycle-hooks>> via <<the-state-store>>.

[source,js]
----
const res = await this._dataAccess.getChainState('hello:helloCounter');
----

[NOTE]
====
The data is encoded in the database, therefore it needs to be decoded after receiving it with `this._dataAccess`.

For more information about this topic, check out the xref:{url_advanced_schemas}[] page.
====

The following functions are available via `this._dataAccess`:

[source,js]
----
export interface BaseModuleDataAccess {
	getChainState(key: string): Promise<Buffer | undefined>;
	getAccountByAddress<T>(address: Buffer): Promise<Account<T>>;
	getLastBlockHeader(): Promise<BlockHeader>;
}
----

== State changes & execution logic

The parts which contain the logic to do state mutation on the blockchain are maybe the most important part of the module, as they define the underlying business logic and general behavior of a module.

Beside sending transactions, it is also possible to change the state of the blockchain in the <<reducers>> and <<lifecycle-hooks>> of a module.

=== The state store

The `stateStore` is used to mutate the state of the blockchain data, or to retrieve data from the blockchain.

Inside of a module, the `stateStore` is available for <<reducers>>, <<assets>> and all <<lifecycle-hooks>>.

.Interface of `stateStore`
[source,typescript]
----
interface StateStore {
	readonly account: {
		get<T = AccountDefaultProps>(address: Buffer): Promise<Account<T>>;
		getOrDefault<T = AccountDefaultProps>(address: Buffer): Promise<Account<T>>;
		set<T = AccountDefaultProps>(address: Buffer, updatedElement: Account<T>): Promise<void>;
		del(address: Buffer): Promise<void>;
	};
	readonly chain: {
		lastBlockHeaders: ReadonlyArray<BlockHeader>;
		lastBlockReward: bigint;
		networkIdentifier: Buffer;
		get(key: string): Promise<Buffer | undefined>;
		set(key: string, value: Buffer): Promise<void>;
	};
}
----

=== Channel

The channel in modules has one purpose: it allows a module to publish events to the application which were defined in the <<events>> property of the module.

The channel is accessible inside of a module under `this._channel`.
It is used especially in the <<lifecycle-hooks>>, to publish the events of the module.

This is an example how to use the channel to publish an event:

[source,js]
----
this._channel.publish('hello:newHello', {
  sender: transaction._senderAddress.toString('hex'),
  hello: helloAsset.helloString
});
----

The above code example will publish the event `hello:newHello` to the application, and attach an object which is containing the sender address and the hello message of the last sent xref:{url_tutorials_hello_asset}[hello transaction].

For more information about channels, check out the xref:{url_advanced_communication}[] page.

=== Reducers

Reducers are like <<actions>>, but they can only be invoked by other modules.

In contrast to actions, reducers have therefore also access to the <<the-state-store,state store>>.

==== The reducer handler

The `reducerHandler` allows <<lifecycle-hooks>> and <<assets>> to invoke reducers of other modules.

.Invoking the debit reducer of the token module
[source,js]
----
// debit tokens from sender account
await reducerHandler.invoke("token:debit", {
  address: senderAddress,
  amount: asset.initValue,
});
----

=== Assets

Assets are responsible for executing logic that introduces state changes on the blockchain, based on input parameters which are provided by the users as trasnactions.

IMPORTANT: All of the logic implemented in a module / asset must be “deterministic” and executable within the block time.

A blockchain application can accept many different kinds of transactions, depending on its use case.
Every transaction type is handled by a specific <<asset>> of a module in the application.
The xref:{url_advanced_architecture_defaultapp}[default application] already supports the following transactions:

* xref:{url_token_module}[]: Token transfer
* xref:{url_dpos_module}[]:
** Delegate registration
** Delegate vote
** Token unlock
** Delegate misbehavior report
* xref:{url_keys_module}[]: Multisignature group registration

To add support for a new transaction to the application, it is required to implement a new <<assets,asset>> and to add it to the module.

A module can include various transaction assets, that handle new transaction types in the application.
Assets contain all logic related to transactions that belong to the module.

TIP: To learn how to create a new asset, check out the xref:{url_guides_asset}[] guide.

==== Asset anatomy

Each new asset is constructed as a class which extends from the xref:{url_references_framework_baseasset}[BaseAsset].

The base asset provides an interface which needs to be completed by implementing the below described components of an asset.

image::intro/asset.png[]

==== Schema

The asset schema defines the *custom data structure of the transaction*.

It defines which properties can be included, if they are optional or required, and also which data types are to expect.

If a transaction object does not match the corresponding schema, the transaction wont be accepted by the node.

==== Validate

As the name suggests, the `validate()` function validates the posted transaction data, to check it has the expected format.

The following variables are available inside the `validate()` function:

* `asset`: The custom data of the transaction (defined in <<schema>>) posted to the node.
* `transaction`: The complete transaction object which was posted to the node.

If the function throws any error, the transaction will not be applied by the node.

If the function does not throw any errors, the transaction will passed to the `apply()` function.

==== Apply

The `apply()` function of an asset applies the desired business logic on the blockchain, based on the data posted in the transaction.

The following variables are available inside the `apply()` function:

* `asset`: The custom data of the transaction (defined in <<schema>>) posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.
* `transaction`: The complete transaction object which was posted to the node.

=== Lifecycle Hooks

Lifecycle hooks allow to execute logic at distinct moments in the xref:{url_advanced_architecture_lifecycle}[block lifecycle] of the application.

==== beforeTransactionApply()
This hook is applied before each transaction.

The following variables are available inside this hook:

* `transaction`: The complete transaction object which was posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== afterTransactionApply()
This hook is applied after each transaction.

The following variables are available inside this hook:

* `transaction`: The complete transaction object which was posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== afterGenesisBlockApply()
This hook is applied after the genesis block.

The following variables are available inside this hook:

* `genesisBlock`: The xref:{url_advanced_architecture_genesisblock}[genesis block] of the application.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== beforeBlockApply()
This hook is applied before each block.

The following variables are available inside this hook:

* `block`: The block before it is applied on the blockchain.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== afterBlockApply()
This hook is applied after each block.

The following variables are available inside this hook:

* `block`: The block after it is applied on the blockchain.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.
* `consensus`: See <<consensus>>

==== Consensus

`consensus` offers different consensus related functions to get and set the list of active delegates, and to get the finalized height of the blockchain.

.consensus interface
[source,typescript]
----
{
	getDelegates: () => Promise<Delegate[]>; // <1>
	updateDelegates: (delegates: Delegate[]) => Promise<void>; // <2>
	getFinalizedHeight: () => number; // <3>
}
----

<1> Get a list of the actively forging delegates in the current round.
<2> Update the list of deleegates for the current round.
<3> Returns the currently finalized height of the blockchain.

== Account schema

The account schema allows a module to store module-specific data in the user accounts.

The definition of this schema is totally flexible and it is possible to define very complex data structures as well, if needed.

[TIP]

====
For more information about accounts, check the xref:{url_protocol_accounts}[] page of the Lisk protocol.
====

Account schemas are defined in a modified JSON schema.
For more information about this topic, check out the xref:{url_advanced_schemas}[] page.

.Example of an account schema
[source,js]
----
accountSchema = {
    type: 'object',
    properties: {
        helloMessage: {
            fieldNumber: 1,
            dataType: 'string',
        },
    },
    default: {
        helloMessage: '',
    },
};
----

The defined properties in the account schema will be available for every user account.
They will be grouped under a key named after the <<module-name>>.

If a module with module name `hello` is registered in a xref:{url_advanced_architecture_defaultapp}[default application] with the above example of an account schema, the user accounts would look like this:

.Example user account
[source,js]
----
{
  "address": "ae6fff8b9c9c3a8b38193d2186638f684d64d887",
  "token": {
    "balance": "20000000000"
  },
  "sequence": {
    "nonce": "0"
  },
  "keys": {
    "numberOfSignatures": 0,
    "mandatoryKeys": [],
    "optionalKeys": []
  },
  "dpos": {
    "delegate": {
      "username": "",
      "pomHeights": [],
      "consecutiveMissedBlocks": 0,
      "lastForgedHeight": 0,
      "isBanned": false,
      "totalVotesReceived": "0"
    },
    "sentVotes": [],
    "unlocking": []
  },
  "hello": {
    "helloMessage": ""
  }
}
----

