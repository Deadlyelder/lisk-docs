= Modules
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
// URLs
:url_github_hello_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/hello-world/blockchain_app/hello_module/hello_module.js
:url_github_nft_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/nft/blockchain_app/nft_module/index.js
:url_github_srs_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/social-recovery/blockchain_app/srs_module/index.js
// Project URLs
:url_advanced_architecture_defaultapp: advanced-explanations/architecture.adoc#application
:url_advanced_architecture_genesisblock: advanced-explanations/architecture.adoc#genesis-block
:url_advanced_communication: advanced-explanations/communication.adoc
:url_advanced_communication_interfaces: advanced-explanations/communication.adoc#interfaces
:url_advanced_schemas: advanced-explanations/schemas.adoc
:url_intro_bapps_onchain: introduction/blockchain-applications.adoc#on-chain-logic
:url_guides_setup: guides/app-development/setup.adoc
:url_guides_genesis: guides/app-development/genesis-block.adoc
:url_guides_module: guides/app-development/module.adoc
:url_guides_asset: guides/app-development/asset.adoc
:url_explanations_communication: advanced-explanations/communication.adoc
:url_references_framework_application: references/lisk-framework/index.adoc#application
:url_references_framework_basemodule: references/lisk-framework/index.adoc#the-basemodule
:url_references_framework_baseasset: references/lisk-framework/index.adoc#the-baseasset
:url_dpos_module: references/lisk-framework/dpos-module.adoc
:url_keys_module: references/lisk-framework/keys-module.adoc
:url_sequence_module: references/lisk-framework/sequence-module.adoc
:url_token_module: references/lisk-framework/token-module.adoc
:url_tutorials_hello: tutorials/hello-world.adoc
:url_tutorials_hello_asset: tutorials/hello-world.adoc#the-hello-asset
:url_tutorials_nft: tutorials/nft.adoc
:url_tutorials_srs: tutorials/srs.adoc

Modules hold all logic that is changing the state of the blockchain; or in other words, all logic that makes changes on the chain.

Modules can be registered to a blockchain application to extend the xref:{url_intro_bapps_onchain}[on-chain logic].

.When to create a new module
[NOTE]
====
Modules enable to...

* define how data is stored on the blockchain
* define logic which is executed per block
* define logic which is executed per transaction
====

[TIP]

====
For a more practical guide, how to create a new module, check out the guide xref:{url_guides_module}[].

If you wish to view an example of a fully implemented module, check out the following examples:

* the {url_github_hello_module}[Hello module] from the xref:{url_tutorials_hello}[] tutorial
* the {url_github_nft_module}[NFT module] from the xref:{url_tutorials_nft}[] tutorial
* the {url_github_srs_module}[SRS module] from the xref:{url_tutorials_srs}[] tutorial
====

== Adding a module to the application

Modules need to be registered to becomee available in the application.
If the application was xref:{url_guides_setup}[bootstrapped] with Lisk Commander, they are registered in the file `src/app/modules.ts`.

[WARNING]
====
Registering a new module requires the generation of a new genesis block and therefore always results in a hardfork of the blockchain of the application.

Check out the xref:{url_guides_genesis}[Generating a genesis block] guide for more information on how to generate a new genesis block for your application.
====

.Example: How to register a module with the application in `modules.ts`
[source,typescript]
----
import { Application } from 'lisk-sdk';
import { SomeModule } from "some-module"; <1>

export const registerModules = (app: Application): void => {
    app.registerModule(SomeModule); <2>
};
----

<1> Import the module from an NPM package or from a local path.
<2> Add this line to register the module with the application.

== Module anatomy

All important parts of a module are shown in the below diagram and explained in more detail below.

.Anatomy of a module
image:intro/module-asset.png[]

== The module class

Each module is constructed as a class which extends from the xref:{url_references_framework_basemodule}[BaseModule].

The base module provides an interface which needs to be completed by implementing the below described components of a module.

== Properties

The following 3 properties are accessible throughout the module:

=== Channel

The channel in modules has one purpose: it allows a module to publish events to the application which were defined in the <<events>> property of the module.

The channel is accessible inside of a module under `this._channel`.
It is used especially in the <<lifecycle-hooks>>, to publish the events of the module.

This is an example how to use the channel to publish an event:

[source,js]
----
this._channel.publish('hello:newHello', {
  sender: transaction._senderAddress.toString('hex'),
  hello: helloAsset.helloString
});
----

The above code example will publish the event `hello:newHello` to the application, and attach an object which is containing the sender address and the hello message of the last sent xref:{url_tutorials_hello_asset}[hello transaction].

For more information about channels, check out the xref:{url_advanced_communication}[] page.

=== Logger

The logger is accessible inside of a module under `this._logger`.
As the name suggests, the logger enables to create log messages for the module for the different log levels:

* trace
* debug
* info
* warn
* error
* fatal

[source,js]
----
this._logger.debug(nextRound, 'Updating delegate list for');
----

The logger expects 2 arguments:

. data of the log message (object)
. message of the log message (string)

=== dataAccess

Use the property `this._dataAccess` to get data from the blockchain in the module.

[TIP]
Updating and changing of data on the blockchain is only allowed inside of <<assets>> and <<lifecycle-hooks>> via <<the-state-store>>.

[source,js]
----
const res = await this._dataAccess.getChainState('hello:helloCounter');
----

[NOTE]
====
The data is encoded in the database, therefore it needs to be decoded after receiving it with `this._dataAccess`.

For more information about this topic, check out the xref:{url_advanced_schemas}[] page.
====

The following functions are available via `this._dataAccess`:

[source,js]
----
export interface BaseModuleDataAccess {
	getChainState(key: string): Promise<Buffer | undefined>;
	getAccountByAddress<T>(address: Buffer): Promise<Account<T>>;
	getLastBlockHeader(): Promise<BlockHeader>;
}
----

== Interfaces
Modules can expose interfaces (<<actions>>, <<events>> and <<reducers>>), which allow other components of the application to interact with the module.

Reducers are actions that can only be invoked by other modules of the application.

Actions and Events are exposed to the plugins and to external services.

TIP: View the "Interfaces" section of the xref:{url_advanced_communication_interfaces}[Communication] page to see an overview about the different interfaces and their accessibility in modules, plugins and external services.

=== Actions

Actions are functions which can be invoked via Remote-Procedure-Calls (RPC) by plugins and external services, to request data from the module.

=== Events

Events are published by the module on relevant occasions.
Plugins and external services can subscribe to these events and as a result, they will be notified every time a new event is published.

== State changes & execution logic

The parts which contain the logic to do state mutation on the blockchain are maybe the most important part of the module, as they define the underlying business logic and general behavior of a module.

The main way to change the state of the blockchain, is to send transactions to the node.

IMPORTANT: All of the logic implemented in a module / asset must be “deterministic” and executable within the block time.

A blockchain application can accept many different kinds of transactions, depending on its use case.
Every transaction type is handled by a specific module in the application.
The xref:{url_advanced_architecture_defaultapp}[default application] already supports the following transactions:

* xref:{url_token_module}[]: Token transfer
* xref:{url_dpos_module}[]:
** Delegate registration
** Delegate vote
** Token unlock
** Delegate misbehavior report
* xref:{url_keys_module}[]: Multisignature group registration

To add support for a new transaction to the application, it is required to implement a new <<assets,transaction asset>> and to add it to the module.

Beside sending transactions, it is also possible to change the state of the blockchain in the <<reducers>> and <<lifecycle-hooks>> of a module.

=== The state store

The `stateStore` is used to mutate the state of the blockchain data, or to retrieve data from the blockchain.

Inside of a module, the `stateStore` is available for <<reducers>>, <<assets>> and all <<lifecycle-hooks>>.

.Interface of `stateStore`
[source,typescript]
----
interface StateStore {
	readonly account: {
		get<T = AccountDefaultProps>(address: Buffer): Promise<Account<T>>;
		getOrDefault<T = AccountDefaultProps>(address: Buffer): Promise<Account<T>>;
		set<T = AccountDefaultProps>(address: Buffer, updatedElement: Account<T>): Promise<void>;
		del(address: Buffer): Promise<void>;
	};
	readonly chain: {
		lastBlockHeaders: ReadonlyArray<BlockHeader>;
		lastBlockReward: bigint;
		networkIdentifier: Buffer;
		get(key: string): Promise<Buffer | undefined>;
		set(key: string, value: Buffer): Promise<void>;
	};
}
----

=== Reducers

Reducers are <<actions>> which can be invoked exclusively by other modules.

In contrast to actions, reducers have therefore also access to the <<the-state-store,state store>>.

==== The reducer handler

The `reducerHandler` allows <<lifecycle-hooks>> and <<assets>> to invoke reducers of other modules.

.Invoking the debit reducer of the token module
[source,js]
----
// debit tokens from sender account
await reducerHandler.invoke("token:debit", {
  address: senderAddress,
  amount: asset.initValue,
});
----

=== Assets

A module can include various custom transaction assets, that handle new transaction types in the application.
Assets contain all logic related to transactions that belong to the module.

.When to create a new asset
[NOTE]
====
Create a new asset for every new transaction type that you want to use in the blockchain application.

Assets enable to...

* define a schema for data sent through transaction asset
* validate the data
* define logic which is executed per asset
====

TIP: To learn how to create a new asset, check out the xref:{url_guides_asset}[] guide.

==== Asset anatomy

Each new asset is constructed as a class which extends from the xref:{url_references_framework_baseasset}[BaseAsset].

The base asset provides an interface which needs to be completed by implementing the below described components of an asset.

image::intro/asset.png[]

==== Schema

The asset schema defines the *custom data structure of the transaction*.

It defines which properties can be included, if they are optional or required, and also which data types are to expect.

If a transaction object does not match the corresponding schema, the transaction wont be accepted by the node.

==== Validate

As the name suggests, the `validate()` function validates the posted transaction data, to check it has the expected format.

The following variables are available inside the `validate()` function:

* `asset`: The custom data of the transaction (defined in <<schema>>) posted to the node.
* `transaction`: The complete transaction object which was posted to the node.

If the function throws any error, the transaction will not be applied by the node.

If the function does not throw any errors, the transaction will passed to the `apply()` function.

==== Apply

The `apply()` function of an asset applies the desired business logic on the blockchain, based on the data posted in the transaction.

The following variables are available inside the `apply()` function:

* `asset`: The custom data of the transaction (defined in <<schema>>) posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.
* `transaction`: The complete transaction object which was posted to the node.

=== Lifecycle Hooks

==== beforeTransactionApply()
This hook is applied before each transaction.

The following variables are available inside this hook:

* `transaction`: The complete transaction object which was posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== afterTransactionApply()
This hook is applied after each transaction.

The following variables are available inside this hook:

* `transaction`: The complete transaction object which was posted to the node.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== afterGenesisBlockApply()
This hook is applied after the genesis block.

The following variables are available inside this hook:

* `genesisBlock`: The xref:{url_advanced_architecture_genesisblock}[genesis block] of the application.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== beforeBlockApply()
This hook is applied before each block.

The following variables are available inside this hook:

* `block`: The block before it is applied on the blockchain.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.

==== afterBlockApply()
This hook is applied after each block.

The following variables are available inside this hook:

* `block`: The block after it is applied on the blockchain.
* `stateStore`: See <<the-state-store>>.
* `reducerHandler`: See <<the-reducer-handler>>.
* `consensus`:

//TODO: Add description for consensus

== Account schema
Modules define an account schema to store the module related data in the account.
The definition of this schema is totally flexible and it is possible to define very complex data structures as well, if needed.

