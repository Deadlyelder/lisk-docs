= Modules
Mona Bärenfänger <mona@lightcurve.io>
//Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
// URLs
:url_github_hello_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/hello-world/blockchain_app/hello_module/hello_module.js
:url_github_nft_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/nft/blockchain_app/nft_module/index.js
:url_github_srs_module: https://github.com/LiskHQ/lisk-sdk-examples/blob/development/tutorials/social-recovery/blockchain_app/srs_module/index.js
// Project URLs
:url_intro_bapps_onchain: introduction/blockchain-applications.adoc#on-chain-logic
:url_guides_genesis: guides/app-development/genesis-block.adoc
:url_guides_module: guides/app-development/module.adoc
:url_explanations_communication: advanced-explanations/communication.adoc
:url_references_framework_application: references/lisk-framework/index.adoc#application
:url_references_framework_basemodule: references/lisk-framework/index.adoc#the-basemodule
:url_references_framework_baseasset: references/lisk-framework/index.adoc#the-baseasset
:url_dpos_module: references/lisk-framework/dpos-module.adoc
:url_keys_module: references/lisk-framework/keys-module.adoc
:url_sequence_module: references/lisk-framework/sequence-module.adoc
:url_token_module: references/lisk-framework/token-module.adoc
:url_tutorials_hello: tutorials/hello-world.adoc
:url_tutorials_hello_asset: tutorials/hello-world.adoc#the-hello-asset
:url_tutorials_nft: tutorials/nft.adoc
:url_tutorials_srs: tutorials/srs.adoc

Modules hold all logic that is changing the state of the blockchain; or in other words, all logic that makes changes on the chain.

Modules can be registered to a blockchain application to extend the xref:{url_intro_bapps_onchain}[on-chain logic].

IMPORTANT: All of the logic implemented using a custom module / asset must be “deterministic” and executable within the block time.

.When to create a custom module
[NOTE]
====
Modules enable to...

* define how data is stored on the blockchain
* define logic which is executed per block
* define logic which is executed per transaction
====

[TIP]

====
For a more practical guide, how to create a new module, check out the guide xref:{url_guides_module}[].

If you wish to view an example of a fully implemented module, check out the following examples:

* the {url_github_hello_module}[Hello module] from the xref:{url_tutorials_hello}[] tutorial
* the {url_github_nft_module}[NFT module] from the xref:{url_tutorials_nft}[] tutorial
* the {url_github_srs_module}[SRS module] from the xref:{url_tutorials_srs}[] tutorial
====

== Module anatomy

All important parts of a module are shown in the below diagram and explained in more detail below.

.Anatomy of a module
image:intro/module-asset.png[]

//TODO: Update module class description
== The module class

Each module is constructed as a class which extends from the xref:{url_references_framework_basemodule}[BaseModule].

The base module provides an interface which needs to be completed by implementing the below described components of a module.
It also provides the following 3 properties which are accessible throughout the module:

=== Channel

The channel in modules has one purpose: it allows a module to publish events to the application which were defined in the <<events>> property of the module.

The channel is accessible inside of a module under `this._channel`.
It is used especially in the <<lifecycle-hooks>>, to publish the events of the module.

This is an example how to use the channel to publish an event:

[source,js]
----
this._channel.publish('hello:newHello', {
  sender: transaction._senderAddress.toString('hex'),
  hello: helloAsset.helloString
});
----

The above code example will publish thee event `hello:newHello` to the application, and attach an object which is containing the sender address and the hello message of the last sent xref:{url_tutorials_hello_asset}[hello transaction].

=== Logger

=== dataAccess
Use the property `this._dataAccess` to access data from the blockchain in the module.

[TIP]
Updating and changing of data on the blockchain is only allowed inside of <<assets>> and <<lifecycle-hooks>> via <<the-state-store>>.

== Interfaces
Modules can expose interfaces, which allow other components of the application to interact with the module.
Reducers are actions that can only be invoked by other modules of the application.
Actions and Events are exposed to the plugins and to external services.
More information about the exposed interface can be found in the section about the xref:{url_explanations_communication}[].

=== Actions
=== Events
=== Reducers
== State changes & execution logic

=== The state store

=== Assets

Transaction assets contain all logic related to transactions that belong to the module.

.When to create a new asset
[NOTE]
====
Create a new asset for every new transaction type that you want to use in the blockchain application.

Assets enable to...

* define a schema for data sent through transaction asset
* validate the data
* define logic which is executed per asset
====

=== Lifecycle Hooks

==== beforeTransactionApply()
This hook is applied before each transaction.

The following parameters are available inside this hook:



==== afterTransactionApply()
This hook is applied after each transaction.

==== afterGenesisBlockApply()
This hook is applied after the genesis block.

==== beforeBlockApply()
This hookis applied before each block.

==== afterBlockApply()
This hook is applied after each block.



== Account schema
Modules define an account schema to store the module related data in the account.
The definition of this schema is totally flexible and it is possible to define very complex data structures as well, if needed.



== How to add a module to the application

Modules are registered in the file `src/app/modules.ts`.

[WARNING]
====
Registering a new module requires the generation of a new genesis block and therefore always results in a hardfork of the blockchain of the application.

Check out the xref:{url_guides_genesis}[Generating a genesis block] guide for more information on how to generate a new genesis block for your application.
====

.Example: How to register a module with the application in `modules.ts`
[source,typescript]
----
import { Application } from 'lisk-sdk';
import { SomeModule } from "some-module"; <1>

export const registerModules = (app: Application): void => {
    app.registerModule(SomeModule); <2>
};
----

<1> Import the module from an NPM package or from a local path.
<2> Add this line to register the module with the application.


