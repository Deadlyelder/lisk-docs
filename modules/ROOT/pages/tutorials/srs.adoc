= Social Recovery System (SRS)
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc:
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:experimental:
// External URLs
:url_github_srs: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/srs
:url_react_docs: https://reactjs.org/docs/getting-started.html
// Project URLs
:url_references_schemas: references/schemas.adoc
:url_statestore: references/lisk-elements/chain.adoc#state-store
:url_references_token_module: token-module.adoc

In the SRS tutorial, you learn step-by-step how to create a blockchain application which offers users a feature to recover the balance of their accounts for the scenario that they have lost/forgotten their passphrase.

The goal is to build an account recovery tool where a user asks friends to give the user access to the funds of a lost account.
The user defines a recovery configuration initially by setting a list of friends and some other parameters for the recovery.

TIP: For the *full code example* please see the {url_github_srs}[SRS app on GitHub^].

== SRS application overview

image:tutorials/srs/srs-overview.png[]

As the above image describes, we need to create the following components:

. The SRS module (on-chain)
.. 6 new transaction assets for the SRS module
.. 3 SRS-specific events
. Plugins (off-chain)
.. The SRS data plugin
... 1 action
.. The SRS API plugin

Additional to the blockchain application, we will also implement **frontend application**, which allows us to interact with the blockchain application through a UI in the browser.

:sectnums:

== Project setup

Create a new folder which will contain all the files for the SRS app:

[source,bash]
----
mkdir srs
mkdir srs/blockchain_app
cd srs/blockchain_app
npm init --yes
npm i lisk-sdk
----

Next, create a new file `index.js` and paste the following:

.srs/blockchain_app/index.js
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');

const app = Application.defaultApplication(genesisBlockDevnet, configDevnet);

app
	.run()
	.then(() => app.logger.info('App started...'))
	.catch(error => {
		console.error('Faced error in application', error);
		process.exit(1);
	});
----

This code snippet creates a default blockchain application, which is configured for development purposes.
Use this app as basis for the SRS app and extend it with a module and a plugin in the next steps, to suit the desired use case.

== Transaction assets

Users shall have the ability to:

[start=0]
. Create recovery configs for their account.
. Initiate a recovery for an account which has a recovery config.
. Vouch for a rescuer account, if certain conditions are met.
. Claim a recovery, if certain conditions are met.
. Cancel a recovery, for example if they found their passphrase from the old account again.
. Remove a recovery config again from the account.

To do this, we create the corresponding transaction assets for the SRS module.
These transaction assets each define both, the asset schema for the transaction data, and the logic, how this data is applied and stored in the database.

Create a new folder `srs_module/` and inside another new folder `transactions`:

.srs/blockchain_app/
[source,bash]
----
mkdir srs_module
mkdir srs_module/transactions <1>
cd srs_module/transactions/
----

<1> Create a new folder `transactions/` which will contain the files for the transaction assets.

=== createRecovery asset
Create a new file `create_recovery.js` inside the newly created `transactions/` folder.

Now open the file and paste the code below:

.srs/blockchain_app/srs_module/transactions/create_recovery.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement the custom asset
class CreateRecoveryAsset extends BaseAsset { <1>

}

module.exports = { CreateRecoveryAsset }; <2>
----

<1> Extend from the base asset to implement a custom asset.
<2> Export the asset, so it can be imported later into the custom module.

Now all required properties for the transaction asset are defined one after another.

==== Asset ID and name
.srs/blockchain_app/srs_module/transactions/create_recovery.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

const CREATE_RECOVERY_ASSET_ID = 0;

// extend base asset to implement your custom asset
class CreateRecoveryAsset extends BaseAsset {
  // define unique asset name and id
  name = "createRecovery"; <1>
  id = CREATE_RECOVERY_ASSET_ID; <2>
}

module.exports = { CreateRecoveryAsset, CREATE_RECOVERY_ASSET_ID }; <3>
----

<1> Set the asset name to `"createRecovery"`.
<2> Set the asset id to `0`.
<3> Export the asset ID for later use in the application.

==== Asset schema

The asset schema describes the required datatypes and the structure of the data in the respective transaction asset.

TIP: For more information how schemas are used in the application, check out the xref:{url_references_schemas}[] reference.

For creating a recovery configuration, the following information is required:

* `friends`: A list of trusted adresses.
* `recoveryThreshold`: Minimum amount of friends that need to vouch for a rescuer, before the rescuer can claim the recovery.
* `delayPeriod`: The % value of the initial value, that is added to the initial value when purchasing the NFT.

To be able to import the schema conveniently later in the module, create a new file `schemas.js`.

Here we store the schemas which are reused later in different places of the application.

.srs/blockchain_app/srs_module/schemas.js
[source,js]
----
const createRecoverySchema = {
  $id: 'srs/recovery/create',
  type: 'object',
  required: ['friends', 'recoveryThreshold', 'delayPeriod'],
  properties: {
    friends: {
      type: 'array',
      fieldNumber: 1,
      items: {
        dataType: 'bytes',
      },
    },
    recoveryThreshold: {
      dataType: 'uint32',
      fieldNumber: 2,
    },
    delayPeriod: {
      dataType: 'uint32',
      fieldNumber: 3,
    },
  },
};

module.exports = { createRecoverySchema };
----

Now import is into `create_recovery.js`.

.srs/blockchain_app/srs_module/transactions/create_recovery.js
[source,js]
----
const { BaseAsset } = require('lisk-sdk');
const { createRecoverySchema } = require('../schemas');

const CREATE_RECOVERY_ASSET_ID = 0;

class CreateRecoveryAsset extends BaseAsset {
	name = 'createRecovery';
	id = CREATE_RECOVERY_ASSET_ID;
	schema = createRecoverySchema;
}

module.exports = { CreateRecoveryAsset, CREATE_RECOVERY_ASSET_ID };
----

==== The apply function

The `apply()` function has access to:

* `asset`: the posted transaction asset.
* `stateStore`: The xref:{url_statestore}[state store] is a data structure that holds temporary state while processing a block.
It is used here to get and set certain data from and to the database.
* `reducerHandler`: Allows to use reducer functions of other modules inside the `apply()` function.
* `transaction`: the complete transaction object.

.srs/blockchain_app/srs_module/transactions/create_recovery.js
[source,js]
----
const { BaseAsset, transactions } = require('lisk-sdk');
const { createRecoverySchema } = require('../schemas');

const BASE_RECOVERY_DEPOSIT = '1000000000';
const FRIEND_FACTOR_FEE = 2;
const CREATE_RECOVERY_ASSET_ID = 0;

class CreateRecoveryAsset extends BaseAsset {
	name = 'createRecovery';
	id = CREATE_RECOVERY_ASSET_ID;
	schema = createRecoverySchema;

    async apply({
		asset,
		transaction,
		stateStore,
	}) {
        const sender = await stateStore.account.get(transaction.senderAddress);
        if (sender.srs.config && sender.srs.config.friends.length !== 0) {
            throw Error('Account already has a recovery configuration.')
        }
        const sameAccount = asset.friends.find(f => f === sender.address);
        if (sameAccount) {
            throw new Error('You cannot add yourself to the friend list.');
        }
        // Add friends to the list
        sender.srs.config.friends = [...asset.friends.sort()];
        // Minimum number of friends required to vouch
        sender.srs.config.recoveryThreshold = asset.recoveryThreshold;
        // Minimum number of blocks after recovery process when account will be recoverable
        sender.srs.config.delayPeriod = asset.delayPeriod;
        // Set the deposit based on number of friends, 10 + friends.length * 2
        const deposit = BigInt(BASE_RECOVERY_DEPOSIT) + BigInt(transactions.convertLSKToBeddows((sender.srs.config.friends.length * FRIEND_FACTOR_FEE).toString()));
        sender.srs.config.deposit = deposit;
        // Save the value in stateStore
        await stateStore.account.set(sender.address, sender);
    }
}

module.exports = { CreateRecoveryAsset, CREATE_RECOVERY_ASSET_ID };
----

The other transaction assets are created analog to the `CreateRecoveryAsset`

=== initiateRecovery asset

Add the respective asset schema to `schemas.js` and require it then in the transaction asset:

.srs/blockchain_app/srs_module/schemas.js
[source,js]
----
//...

const initiateRecoverySchema = {
  $id: 'srs/recovery/initiate',
  type: 'object',
  required: ['lostAccount'],
  properties: {
    lostAccount: {
      dataType: 'bytes',
      fieldNumber: 1,
    },
  },
};

module.exports = { createRecoverySchema, initiateRecoverySchema };
----

.srs/blockchain_app/srs_module/transactions/create_recovery.js
[source,js]
----
const { BaseAsset } = require('lisk-sdk');
const { initiateRecoverySchema } = require('../schemas');

const INITIATE_RECOVERY_ASSET_ID = 1;

class InitiateRecoveryAsset extends BaseAsset {
	name = 'initiateRecovery';
	id = INITIATE_RECOVERY_ASSET_ID;
	schema = initiateRecoverySchema;

    async apply({
		asset,
		transaction,
		stateStore,
        reducerHandler,
	}) {
        const rescuer = await stateStore.account.get(transaction.senderAddress);
        const lostAccount = await stateStore.account.get(asset.lostAccount);

        const sameAccount = lostAccount.srs.config.friends.find(f => f === rescuer.address);
        if (sameAccount) {
            throw new Error('You cannot recover your own account.');
        }

        // Check if recovery configuration is present for the lost account or not
        if (lostAccount.srs.config && lostAccount.srs.config.friends.length === 0) {
            throw Error('Lost account has no recovery configuration.')
        }

        const currentHeight = stateStore.chain.lastBlockHeaders[0].height;
        const deposit = lostAccount.srs.config.deposit;

        // Check if rescuer account has enough balance
        const rescuerBalance = await reducerHandler.invoke('token:getBalance', {
            address: rescuer.address,
        });

        if (deposit > rescuerBalance) {
            throw new Error('Rescuer doesnt have enough balance to deposit for recovery process.');
        }
        // Deduct the balance from rescuer and update rescuer account
        await reducerHandler.invoke('token:debit', {
            address: rescuer.address,
            amount: deposit,
          });

        // Update lost account address to active recovery
        lostAccount.srs.status.active = true;
        lostAccount.srs.status.rescuer = rescuer.address;
        lostAccount.srs.status.created = currentHeight;
        lostAccount.srs.status.deposit = deposit;
        lostAccount.srs.status.vouchList = [];

        // Save lost account values to stateStore
        await stateStore.account.set(lostAccount.address, lostAccount);
    }
}

module.exports = { InitiateRecoveryAsset, INITIATE_RECOVERY_ASSET_ID };
----

=== vouchRecovery asset

.srs/blockchain_app/srs_module/transactions/vouch_recovery.js
[source,js]
----
const { BaseAsset } = require('lisk-sdk');

class VouchRecoveryAsset extends BaseAsset {
	name = 'vouchRecovery';
	id = 2;
	schema = {
        $id: 'srs/recovery/vouch',
        type: 'object',
        required: ['lostAccount', 'rescuer'],
        properties: {
            rescuer: {
                dataType: 'bytes',
                fieldNumber: 1,
              },
            lostAccount: {
                dataType: 'bytes',
                fieldNumber: 2,
            },
        },
    };

    async apply({
		asset,
		transaction,
		stateStore,
	}) {
        const sender = await stateStore.account.get(transaction.senderAddress);
        const lostAccount = await stateStore.account.get(asset.lostAccount);
        const rescuer = await stateStore.account.get(asset.rescuer);

        // Make sure rescuer and lost account match according to config settings
        if (!lostAccount.srs.status.rescuer.equals(rescuer.address)) {
            throw new Error(`Rescuer address is incorrect for the recovery of ${lostAccount.address.toString('hex')}`)
        }

        const found = lostAccount.srs.config.friends.find(f => f.equals(sender.address));
        // Make sure friend is present in the configuration
        if (!found) {
            throw new Error('The sender is not part of friends who can vouch for rescuer for recovery process.')
        }

        const foundSignature = lostAccount.srs.status.vouchList.find(f => f.equals(sender.address));
        // Make sure the friend has not already voted
        if (foundSignature) {
            throw new Error('The sender has already vouched for the rescuer for recovery process.')
        }

        // Push signature to vouch list
        lostAccount.srs.status.vouchList.push(sender.address);
        await stateStore.account.set(lostAccount.address, lostAccount);
    }
}

module.exports = VouchRecoveryAsset;
----

=== claimRecovery asset

.srs/blockchain_app/srs_module/transactions/claim_recovery.js
[source,js]
----
const { BaseAsset } = require('lisk-sdk');

class ClaimRecoveryAsset extends BaseAsset {
	name = 'claimRecovery';
	id = 3;
	schema = {
        $id: 'srs/recovery/claim',
        type: 'object',
        required: ['lostAccount'],
        properties: {
            lostAccount: {
                dataType: 'bytes',
                fieldNumber: 1,
            },
        },
    };

    async apply({
		asset,
		transaction,
		stateStore,
        reducerHandler,
	}) {
        const rescuer = await stateStore.account.get(transaction.senderAddress);
        const lostAccount = await stateStore.account.get(asset.lostAccount);

        const currentHeight = stateStore.chain.lastBlockHeaders[0].height;
        const delayPeriod = lostAccount.srs.config.delayPeriod;
        const recoveryThreshold = lostAccount.srs.config.recoveryThreshold;
        const deposit = lostAccount.srs.config.deposit;

        // Check if the delay period is passed to claim the recovery
        if ((currentHeight - rescuer.srs.status.created) < delayPeriod) {
            throw new Error(`Cannot claim account before delay period of ${delayPeriod}.`);
        }

        // Check if the recovery has received minimum number of vouch from friends
        if (lostAccount.srs.status.vouchList.length < recoveryThreshold) {
            throw new Error(`Cannot claim account until minimum threshold of ${lostAccount.srs.config.friends.length} friends have vouched.`);
        }

        const minBalance = await reducerHandler.invoke('token:getMinRemainingBalance');
        // Get the account balance of lost account
        const lostAccountBalance = await reducerHandler.invoke('token:getBalance', {
            address: lostAccount.address,
        });

        await reducerHandler.invoke('token:debit', {
            address: lostAccount.address,
            // Get the deposit back from the lost account as well as your own deposit that was locked
            amount: lostAccountBalance - minBalance,
        });

        await reducerHandler.invoke('token:credit', {
            address: rescuer.address,
            // Get the deposit back from the lost account as well as your own deposit that was locked
            amount: BigInt(2) * deposit + lostAccountBalance - minBalance,
        });

        // Reset recovery status
        await stateStore.account.set(rescuer.address, rescuer);
        // Reset all recovery values in the lost account
        lostAccount.srs.config.friends = [];
        lostAccount.srs.config.delayPeriod = 0;
        lostAccount.srs.config.recoveryThreshold = 0;
        lostAccount.srs.config.deposit = BigInt('0');
        lostAccount.srs.status.active = false;
        lostAccount.srs.status.rescuer = Buffer.from('');
        lostAccount.srs.status.created = 0;
        lostAccount.srs.status.deposit = BigInt('0');
        lostAccount.srs.status.vouchList = [];
        await stateStore.account.set(lostAccount.address, lostAccount);
	}
}

module.exports = ClaimRecoveryAsset;
----

=== closeRecovery asset

.srs/blockchain_app/srs_module/transactions/close_recovery.js
[source,js]
----
const { BaseAsset } = require('lisk-sdk');

class CloseRecoveryAsset extends BaseAsset {
	name = 'closeRecovery';
	id = 4;
	schema = {
        $id: 'srs/recovery/close',
        type: 'object',
        required: ['rescuer'],
        properties: {
            rescuer: {
                dataType: 'bytes',
                fieldNumber: 1,
            },
        },
    };

    async apply({
		asset,
		transaction,
		stateStore,
        reducerHandler,
	}) {
        const lostAccount = await stateStore.account.get(transaction.senderAddress);
        if (!lostAccount.srs.status.active) {
            throw new Error(`No active recovery found for address ${lostAccount.address.toString('hex')}.`);
        }
        if (!lostAccount.srs.status.rescuer.equals(asset.rescuer)) {
            throw new Error(`Incorrect rescuer address`);
        }

        const rescuer = await stateStore.account.get(asset.rescuer);

        // Debit deposit amount from the rescuer and credit to the lost account
        await reducerHandler.invoke('token:debit', {
            address: rescuer.address,
            amount: lostAccount.srs.config.deposit,
          });

        await reducerHandler.invoke('token:credit', {
            address: lostAccount.address,
            amount: lostAccount.srs.config.deposit,
          });

        // Reset recovery status
        lostAccount.srs.status.active = false;
        lostAccount.srs.status.rescuer = Buffer.from('');
        lostAccount.srs.status.created = 0;
        lostAccount.srs.status.deposit = BigInt('0');
        lostAccount.srs.status.vouchList = [];
        await stateStore.account.set(lostAccount.address, lostAccount);
    }
}

module.exports = CloseRecoveryAsset;
----

=== removeRecovery asset

Add the respective asset schema to `schemas.js` and require it then in the transaction asset:

.srs/blockchain_app/srs_module/schemas.js
[source,js]
----
//...

const removeRecoverySchema = {
  $id: 'srs/recovery/remove',
  type: 'object',
  required: ['lostAccount'],
  properties: {
    lostAccount: {
      dataType: 'bytes',
      fieldNumber: 1,
    },
  },
};

module.exports = { createRecoverySchema, initiateRecoverySchema, removeRecoverySchema };
----

.srs/blockchain_app/srs_module/transactions/remove_recovery.js
[source,js]
----
const {
	BaseAsset
} = require('lisk-sdk');
const { removeRecoverySchema } = require('../schemas');

const REMOVE_RECOVERY_ASSET_ID = 5;

class RemoveRecoveryAsset extends BaseAsset {
	name = 'removeRecovery';
	id = REMOVE_RECOVERY_ASSET_ID;
	schema = removeRecoverySchema;

	async apply({
		transaction,
		stateStore,
		reducerHandler,
	}) {
		const lostAccount = await stateStore.account.get(transaction.senderAddress);

		if (lostAccount.srs.config.friends.length === 0) {
			throw Error('Account does not have a recovery configuration.')
		}

		if (lostAccount.srs.status.active) {
			throw Error('There is active recovery in process. Please close the recovery to remove recovery configuration.')
		}

		const deposit = lostAccount.srs.config.deposit;

		// Unlock the deposit and give it back
		await reducerHandler.invoke('token:credit', {
			address: lostAccount.address,
			amount: deposit,
		});

		// Reset all the default values
		lostAccount.srs.config.friends = [];
		lostAccount.srs.config.recoveryThreshold = 0;
		lostAccount.srs.config.delayPeriod = 0;
		lostAccount.srs.config.deposit = BigInt('0');
		lostAccount.srs.status.rescuer = Buffer.from('');
		lostAccount.srs.status.deposit = BigInt('0');
		lostAccount.srs.status.vouchList = [];
		lostAccount.srs.status.created = 0;
		lostAccount.srs.status.active = false;
		await stateStore.account.set(lostAccount.address, lostAccount);
	}
}

module.exports = { RemoveRecoveryAsset, REMOVE_RECOVERY_ASSET_ID };
----

== The SRS module

Inside the srs_module/ folder, create a new file `index.js`.

Open `index.js` and create the skeleton which will contain all parts of the SRS module:

=== Module ID and name

Set the unique identifier for the SRS module to `srs`, and the module ID to `1026`.

[source,js]
----
const { BaseModule } = require('lisk-sdk');

// Extend from the base module to implement a custom module
class SRSModule extends BaseModule {
  name = 'srs';
  id = 1026;
}

module.exports = { SRSModule };
----

=== The account schema

Open the in section <<asset-schema>> created `schemas.js` file again, and add the account schema for the SRS module:

.srs/blockchain_app/srs_module/schemas.js
[source,js]
----
//...

const SRSAccountSchema = {
    type: 'object',
    required: ['config'],
    properties: {
      config: {
        fieldNumber: 1,
        type: 'object',
        required: ['friends'],
        properties: {
          friends: {
              type: 'array',
              fieldNumber: 1,
              items: {
                  dataType: 'bytes',
              },
          },
          recoveryThreshold: {
              dataType: 'uint32',
              fieldNumber: 2,
          },
          delayPeriod: {
              dataType: 'uint32',
              fieldNumber: 3,
          },
          deposit: {
            dataType: 'uint64',
            fieldNumber: 4,
          }
        },
        default: {
          friends: [],
          recoveryThreshold: 0,
		  delayPeriod: 0,
        },
      },
      status: {
        fieldNumber: 2,
        type: 'object',
        properties: {
          rescuer: {
            dataType: 'bytes',
            fieldNumber: 1,
          },
          created: {
            dataType: 'uint32',
            fieldNumber: 2,
          },
          deposit: {
            dataType: 'uint64',
            fieldNumber: 3,
          },
          vouchList: {
            type: 'array',
            fieldNumber: 4,
            items: {
                dataType: 'bytes',
            },
          },
          active: {
            dataType: 'boolean',
            fieldNumber: 5,
          },
        },
      }
    },
};

module.exports = { SRSAccountSchema, createRecoverySchema, initiateRecoverySchema, removeRecoverySchema };
----

Now use the `SRSAccountSchema` inside of the module:

.srs/blockchain_app/srs_module/index.js
[source,js]
----
const { BaseModule } = require('lisk-sdk');
const { SRSAccountSchema } = require('./schemas');

// Extend from the base module to implement a custom module
class SRSModule extends BaseModule {
  name = 'srs';
  id = 1026;
  accountSchema = SRSAccountSchema;

}

module.exports = { SRSModule };
----

=== Importing the transaction assets into the module

Now let's import the transactions which were created in section 2: <<transaction-assets>> into the module.

Add them to the `tansactionAssets` property like shown in the snippet below.

.Best practise
[TIP]

====
It's a good practise to name the imported transaction assets after their corresponding classname.

In this example: `CreateRecoveryAsset`, `InitiateRecoveryAsset`, `VouchRecoveryAsset`, `ClaimRecoveryAsset`, `CloseRecoveryAsset`, and `RemoveRecoveryAsset`.
====

.srs/blockchain_app/srs_module/index.js
[source,js]
----
const { BaseModule } = require('lisk-sdk');
const  { CreateRecoveryAsset } = require('./assets/create_recovery');
const { InitiateRecoveryAsset } = require('./assets/initiate_recovery');
const VouchRecoveryAsset = require('./assets/vouch_recovery');
const ClaimRecoveryAsset = require('./assets/claim_recovery');
const CloseRecoveryAsset = require('./assets/close_recovery');
const { RemoveRecoveryAsset } = require('./assets/remove_recovery');
const { SRSAccountSchema } = require('./schemas');

// Extend from the base module to implement a custom module
class SRSModule extends BaseModule {
  name = 'srs';
  id = 1026;
  accountSchema = SRSAccountSchema;

  transactionAssets = [
    new CreateRecoveryAsset(),
    new InitiateRecoveryAsset(),
    new VouchRecoveryAsset(),
    new ClaimRecoveryAsset(),
    new CloseRecoveryAsset(),
    new RemoveRecoveryAsset(),
  ];
}

module.exports = { SRSModule };
----

=== Events

Define the events which are available part of this module.

Like described in section <<srs-application-overview>>, define three different events:

* createdConfig
* removedConfig
* initiatedRecovery

.srs/blockchain_app/srs_module/index.js
[source,js]
----
const { BaseModule } = require('lisk-sdk');
const  { CreateRecoveryAsset } = require('./assets/create_recovery');
const { InitiateRecoveryAsset } = require('./assets/initiate_recovery');
const VouchRecoveryAsset = require('./assets/vouch_recovery');
const ClaimRecoveryAsset = require('./assets/claim_recovery');
const CloseRecoveryAsset = require('./assets/close_recovery');
const { RemoveRecoveryAsset } = require('./assets/remove_recovery');
const { SRSAccountSchema } = require('./schemas');

// Extend from the base module to implement a custom module
class SRSModule extends BaseModule {
  name = 'srs';
  id = 1026;
  accountSchema = SRSAccountSchema;

  transactionAssets = [
    new CreateRecoveryAsset(),
    new InitiateRecoveryAsset(),
    new VouchRecoveryAsset(),
    new ClaimRecoveryAsset(),
    new CloseRecoveryAsset(),
    new RemoveRecoveryAsset(),
  ];

  events = ['createdConfig','removedConfig','initiatedRecovery'];

}

module.exports = { SRSModule };
----

=== Lifecycle hooks

Use the life cycle hooks of the module to publish the events we just created in the <<events>> section.

Here we use the hook `afterTransactionApply()`, which is executed each time after a transaction is applied on the blockchain.

.srs/blockchain_app/srs_module/index.js
[source,js]
----
const { BaseModule, codec } = require('lisk-sdk');
const  { CreateRecoveryAsset, CREATE_RECOVERY_ASSET_ID } = require('./assets/create_recovery');
const { InitiateRecoveryAsset, INITIATE_RECOVERY_ASSET_ID } = require('./assets/initiate_recovery');
const VouchRecovery = require('./assets/vouch_recovery');
const ClaimRecovery = require('./assets/claim_recovery');
const CloseRecovery = require('./assets/close_recovery');
const { RemoveRecoveryAsset, REMOVE_RECOVERY_ASSET_ID } = require('./assets/remove_recovery');
const { SRSAccountSchema, createRecoverySchema, initiateRecoverySchema } = require('./schemas');

// Extend from the base module to implement a custom module
class SRSModule extends BaseModule {
  name = 'srs';
  id = 1026;
  accountSchema = SRSAccountSchema;

  transactionAssets = [
    new CreateRecoveryAsset(),
    new InitiateRecoveryAsset(),
    new VouchRecovery(),
    new ClaimRecovery(),
    new CloseRecovery(),
    new RemoveRecoveryAsset(),
  ];

  events = ['createdConfig','removedConfig','initiatedRecovery'];

  async afterTransactionApply({transaction, stateStore, reducerHandler}) {
    // if the transaction is a create recovery transaction
    if (transaction.moduleID === this.id && transaction.assetID === CREATE_RECOVERY_ASSET_ID) {
      // decode the tx asset
      let createRecoveryAsset = codec.decode(
        createRecoverySchema,
        transaction.asset
      );
      const friends = createRecoveryAsset.friends.map(bufferFriend => bufferFriend.toString('hex'));
      // publish the createdConfig event
      this._channel.publish('srs:createdConfig', {
         address: transaction._senderAddress.toString('hex'),
         friends: friends,
         recoveryThreshold: createRecoveryAsset.recoveryThreshold,
         delayPeriod: createRecoveryAsset.delayPeriod
      });
    // if the transaction is a remove recovery transaction
    } else if (transaction.moduleID === this.id && transaction.assetID === REMOVE_RECOVERY_ASSET_ID) {
      // publish the removedConfig event
      this._channel.publish('srs:removedConfig', {
        address: transaction._senderAddress.toString('hex')
      });
    // if the transaction is a initiate recovery transaction
    } else if (transaction.moduleID === this.id && transaction.assetID === INITIATE_RECOVERY_ASSET_ID) {
      // decode the tx asset
      const initiateRecoveryAsset = codec.decode(
        initiateRecoverySchema,
        transaction.asset
      );
      // publish the initiatedRecovery event
      this._channel.publish('srs:initiatedRecovery', {
        address: transaction._senderAddress.toString('hex'),
        config: initiateRecoveryAsset
      });
    }
  };

}

module.exports = { SRSModule };
----

The implementation of the SRS module is now complete.

== The SRS data plugin

To be able to conveniently get a list of all accounts which created a recovery configuration, create a custom plugin.

First, navigate out of the `srs_module` folder, and create a new folder which will store the files for the new plugin.

.srs/blockchain_app/
[source,bash]
----
mkdir srs_data_plugin
cd srs_data_plugin
----

Now create a new file `index.js` inside the newly created `srs_data_plugin/` folder.

Open `index.js` and create the skeleton, which will contain all parts of the SRS data plugin:

.srs/blockchain_app/srs_data_plugin/index.js
[source,js]
----

const { BasePlugin } = require('lisk-sdk');
const pJSON = require('../package.json');

class SRSDataPlugin extends BasePlugin { <1>

  static get alias() { <2>
    return 'SRSData';
  }

  static get info() { <3>
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }

  get defaults() {
    return {};
  }

  get events() {
    return [];
  }
}

module.exports = { SRSDataPlugin }; <4>
----

<1> Extend from the base plugin to implement a custom plugin.
<2> Set the alias for the plugin to `SRSData`.
<3> Set the meta information for the plugin.
Here, we re-use the data from the `package.json` file.
<4> Export the plugin, so it can be imported later into the application.

=== The `load()` function

[source,js]
----
const { BasePlugin, db, codec } = require('lisk-sdk');
const pJSON = require('../package.json');
const fs_extra = require("fs-extra");
const os = require("os");
const path = require("path");

const DB_KEY_CONFIGACCOUNTS = "srs:configAccounts";

const getDBInstance = async (dataPath = '~/.lisk/srs-app/', dbName = 'srs_data_plugin.db') => {
  const dirPath = path.join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);
  await fs_extra.ensureDir(dirPath);
  return new db.KVStore(dirPath); <2>
};

const encodedConfigAccountsSchema = {
  $id: 'srs:configAccounts',
  type: 'object',
  required: ['accounts'],
  properties: {
    accounts: {
      type: 'array',
      fieldNumber: 1,
      items: {
        type: 'object',
        properties: {
          address: {
            dataType: 'bytes',
            fieldNumber: 1,
          },
          friends: {
            type: 'array',
            fieldNumber: 2,
            items: {
              dataType: 'bytes',
            }
          },
          recoveryThreshold: {
            dataType: 'uint32',
            fieldNumber: 3
          },
          delayPeriod: {
            dataType: 'uint32',
            fieldNumber: 4
          }
        }
      },
    },
  },
};

const getConfigAccounts = async (database) => {
  try {
    const encodedConfigAccounts = await database.get(DB_KEY_CONFIGACCOUNTS); <4>
    const { accounts } = codec.decode(encodedConfigAccountsSchema, encodedConfigAccounts);
    return accounts;
  }
  catch (error) {
    return [];
  }
};

const saveConfigAccounts = async (database, accounts) => {
  const encodedConfigs = codec.encode(encodedConfigAccountsSchema, { accounts }); <9>

  await database.put(DB_KEY_CONFIGACCOUNTS, encodedConfigs); <10>
};

class SRSDataPlugin extends BasePlugin {
  _accountsWithConfig = undefined;
  _db = undefined;

  static get alias() {
    return 'SRSData';
  }

  static get info() {
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }

  get defaults() {
    return {};
  }

  get events() {
    return [];
  }

  async load(channel) {
    this._db = await getDBInstance(); <1>
    this._accountsWithConfig =  await getConfigAccounts(this._db); <3>
    channel.subscribe('srs:createdConfig', async (info) => { <5>

      let duplicate = false;
      for (let i = 0; i < this._accountsWithConfig.length; i++) {
        if (this._accountsWithConfig[i].address.toString('hex') === info.address) { <6>
          duplicate = true;
          return;
        }
      }
      if (!duplicate){
        info.address = Buffer.from(info.address, 'hex'); <7>
        info.friends = info.friends.map(friend => Buffer.from(friend, 'hex'));
        this._accountsWithConfig.push(info);
      }
      await saveConfigAccounts(this._db, this._accountsWithConfig); <8>
    });
    channel.subscribe('srs:removedConfig', async (info) => { <11>
      for (let i = 0; i < this._accountsWithConfig.length; i++) {
        if (this._accountsWithConfig[i].address.toString('hex') === info.address) { <12>
          this._accountsWithConfig.splice(i, 1);
          return;
        }
      }
      await saveConfigAccounts(this._db, this._accountsWithConfig); <13>
    });
  }

  async unload() {
  }
}

module.exports = { SRSDataPlugin };
----

<1> The database instance for the SRS data plugin is stored in the variable `this._db`.
<2>
<3>
<4>
<5>
<6>
<7>
<8>
<9>
<10>
<11>
<12>
<13>

=== Create an action to get all accounts with recovery configs



== The SRS API plugin
=== Controllers

== Registering module & plugins

== Frontend application
=== Prepare example accounts

.Example account credentials
----
=======================
Original Account
-----------------------
passphrase:
peanut hundred pen hawk invite exclude brain chunk gadget wait wrong ready
binary address:
d04699e57c4a3846c988f3c15306796f8eae5c1c
base32 address:
lskdxc4ta5j43jp9ro3f8zqbxta9fn6jwzjucw7yt
=======================
Rescuer
-----------------------
passphrase:
endless focus guilt bronze hold economy bulk parent soon tower cement venue
binary address:
9cabee3d27426676b852ce6b804cb2fdff7cd0b5
base32 address:
lsktrqfj84n34tn97vraaq2ztmrgwgwakmqyskqw4
=======================
Friend 1
-----------------------
passphrase:
mushroom edit regular pencil ten casino wine north vague bachelor swim piece
binary address:
463e7e879b7bdc6a97ec02a2a603aa1a46a04c80
base32 address:
lsk32gnhxjs887bqmgoz6y6ozh6c4c6ztpz7wjfa9
=======================
Friend 2
-----------------------
passphrase:
thought talk cherry write armed valve salute fabric auction maid join rebuild
binary address:
328d0f546695c5fa02105deb055cf2801d9b8ba1
base32 address:
lskb6bufqcbrwvgkzuu5wqu6wnruz7awvhxwfkonb
=======================
Friend 3
-----------------------
passphrase:
exist night more net diesel exact will purse orbit vacuum birth wide
binary address:
6174515fa66c91bff1128913edd4e0f1de37cee0
base32 address:
lskomdmvwhb9r3sgj3ryp4fsqnzfn8c8twzkecugt
----

.Send tokens to the example accounts
[source,bash]
----
curl -X POST -H "Content-Type: application/json" \
-d '{"amount":"108489300000000","recipientAddress":"9cabee3d27426676b852ce6b804cb2fdff7cd0b5","data":"transfer to a friend","passphrase":"peanut hundred pen hawk invite exclude brain chunk gadget wait wrong ready"}' \
http://localhost:8080/api/token/transfer

curl -X POST -H "Content-Type: application/json" \
-d '{"amount":"10000000000","recipientAddress":"463e7e879b7bdc6a97ec02a2a603aa1a46a04c80","data":"transfer to a friend","passphrase":"peanut hundred pen hawk invite exclude brain chunk gadget wait wrong ready"}' \
http://localhost:8080/api/token/transfer

curl -X POST -H "Content-Type: application/json" \
-d '{"amount":"10000000000","recipientAddress":"328d0f546695c5fa02105deb055cf2801d9b8ba1","data":"transfer to a friend","passphrase":"peanut hundred pen hawk invite exclude brain chunk gadget wait wrong ready"}' \
http://localhost:8080/api/token/transfer

curl -X POST -H "Content-Type: application/json" \
-d '{"amount":"10000000000","recipientAddress":"6174515fa66c91bff1128913edd4e0f1de37cee0","data":"transfer to a friend","passphrase":"peanut hundred pen hawk invite exclude brain chunk gadget wait wrong ready"}' \
http://localhost:8080/api/token/transfer
----

=== Frontend walkabout
=== API related functions
=== Components

== Summary
