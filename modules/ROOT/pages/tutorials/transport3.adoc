= Transport Tutorial Part 3: Next steps
:toc: preamble
:imagesdir: ../../assets/images
:experimental:
:v_core: master

== 3.1 Make it portable

Currently the packet is not really portable, because it is connected via USB to your machine in order to get power.

To make it portable, all you need is a portable power source, like a battery, that provides the Raspberry Pi with enough power to track the packet for at least a few hours.

The second thing that needs to be done is making the tracking script start automatically after the boot process of the Pi.

`pm2` provides an easy way to let your script start automatically after boot.
On your Raspberry Pi, install `pm2` globally:

[source, bash]
----
npm install pm2 -g
pm2 startup
----

This should print a fitting command for you in the terminal.
Copy it and paste it in the temrinal again to complete the setup of the `pm2` startup script.

Start your tracking script with `pm2`:

.Run this inside the `light_alarm` folder on the Raspberry Pi
[source, bash]
----
pm2 start --name lightAlarm index.js
----

.Add the tracking script to the list of processes, that will be started autmatically when the raspberry pi is started.
[source, bash]
----
pm2 save
----

Now log out from your Raspberry Pi, disconnect it from your machine, and connect it to a portable energy source, like a power bank.
After 1-2 minutes of booting, the tracking script will start running and it will check the light sensor every second.

== 3.2 Connect more nodes

During development it is necessary and convenient to have a rather centralized network with only one node connected.

Once the development has reached the point of proof of concept or a usable product, it's time to add more nodes to the network, and to give other people the opportunity to join the newly created blockchain network.

This is how the setup looks right now:

image:1-node.png[One node diagram]

We want to add one more node to the network, that communicates between the seed node and the Iot and the client app.

image:2-nodes.png[More nodes diagram]

To do so:

=== A) Set up at least one seed node

Set up one or multiple seed node(s).
Every new node will connect to the seed nodes at first, when booting for the first time.
Starting from the seed node, a new node will discover the rest of the network by requesting their peer list and then the peer lists of the newly discovered peers and so on.

The seed node is a node that is specified in the config of the node application under `modules.network.seedPeers` and that should always stay connected to the network.

It's also convenient to have the genesis delegates actively forging on the seed node, in case the network hasn't yet enough real delegates who can take the forging spots.

TIP: The exposed `configDevnet` object is a good template for the config of a seed node, as it includes already all 101 genesis delegates credentials and automatically enables forging for all of them.

=== B) Create a new config suited for your node application

Exchange the `configDevnet` object that we passed to our node during development with your own customized version.

[TIP]
====
It's recommended to create a config object with all the options that you want different from the default config options.
To check the default config options, go to the xref:configuration.adoc[configuration page] or check it out directly in the code: +
`lisk-framework/src/modules/MODULE_NAME/defaults/config.js`. +
Same goes for the components: +
`lisk-framework/src/components/COMPONENT_NAME/defaults/config.js`.
====

Most of the configurations can stay the same to what is defined in the default config options, but there is one option that you should update: **The seed node(s)**.

So to add `1.2.3.4` as a seed node, add an object (or several objects) with the 2 properties `ip` and `wsPort` to the `seedPeers` list:

[source, js]
----
configDevnet.modules.network.seedPeers = [{ ip: '1.2.3.4', wsPort: 5000}]
----

[NOTE]
====
By default, the forging delegates list is empty. +
This is intended, because the genesis delegates are only needed to set up a working dev environment.
Later, you want the `delegates` list to be empty, so users can fill their own credentials there, in case they want to activate forging on their node.

If you wish, e.g. for a proof of concept, to provide already activated forging delegates inside the config, use the devnet genesis delegates in https://github.com/LiskHQ/lisk-sdk/blob/development/sdk/src/samples/config_devnet.json[configDevnet] or create your own genesis delegates and add them to the config.
====

=== C) Publish application

Add the code for your customized `node` application (including the custom transaction types) to a public code repository on e.g. https://github.com/[Github] or https://about.gitlab.com/[Gitlab].

This gives everyone the opportunity to download the application and deploy it on a server in order to connect with the network.

The code should include at least the following files:

* `index.js` :  The code that initializes and starts the node application
* `package.json` : A project file that lists all needed dependencies (this should include `lisk-sdk` as dependency)
* `transactions/` : A folder with all required custom transaction types

=== D) Connect nodes and verify

Let's now add a second node to the network.

This new node will not have any forging activated.
It will be only here to talk via API with the `client` app, and over the websocket connection to the seed node.
The seed node is therefore the only node right now that can forge new blocks, because all genesis delegates are actively forging on it.

TIP: How to replace the genesis delegates with real delegates is covered in the next section <<_3_3_replace_dummy_delegates_with_real_ones, Replace dummy delegates with real ones>>.

To set up the node, just install the published application on a new server.

IMPORTANT: Don't forget to open the corresponding xref:configuration.adoc#_ports[ports] for HTTP and WS communication!

.Snippet of client/app.js
[source,js]
----
// Constants
const API_BASEURL = 'http://134.209.234.204:4000'; <1>
const PORT = 3000;
----

<1> Add here the correct IP and port to the newly added node.

.Logs of newly added node
image:synching_node.png[Synching non forging node]

In the logs above we can see, the seed node was already 3 blocks ahead when we first started the second node.
It first synchronizes the missing blocks up to the current height and then broadcasts the received transactions from the client app to the seed node, where delegates can add the transactions to blocks and forge them.

These new blocks are broadcasted again to the new node, and the client app can display the data based on the API calls that it sends to the new node.

.Log of the seed node with the forging genesis delegates
image:forging_node.png[Forging node logs]

[NOTE]
.Broadcast errors can happen
====
Sometimes there can be errors when broadcasting transactions between nodes.
This is no need to worry!
The node will start the sync process soon again, and most times it is successfull on the next try.
====

image:common-sync-issue.png[Common sync issue]

In the above image the block at height 284 is not accepted because of an invalid block timestamp.
As a result, also the following blocks are discarded by the node as well.

Hick ups like this can happen in the network.
The node can resolve these issues at most times on its own by starting a new sync process, where it requests the missing blocks from one of its' peer nodes.

Like shown in the logs, the blocks at height 284, 285 and 286 are discarded.
Then, the node realizes it is not in sync with the other nodes and starts the sync process, indicated by the logs `Starting sync`.
During the sync process the missing blocks are received from the peers and added to the database of the node.

== 3.3 Replace dummy delegates with real ones

Exchange the dummy delegates with real delegates.

image:3-nodes.png[3 nodes diagram]

== 3.4 Write unit tests for custom transactions

How to test `undoAsset` functions

== 3.5 Task: Add more sensors

Connect more sensors to secure the travel of the packet, e.g. implement a `TemperatureAlarm` or `HumidityAlarm` analog to the `LightAlarm` transaction type.

== 3.6 Task: Add other improvements like GPS tracking or estimated travel times
