= Non-fungible token (NFT)
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc:
:imagesdir: ../../assets/images
:experimental:
// External URLs
:url_github_nft: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/nft
// Project URLs
:url_references_schemas: references/schemas.adoc

In the NFT tutorial, you learn step-by-step how to create modules and plugins which add the feature to create and purchase NFTs to a blockchain application.

TIP: For the *full code example* please see {url_github_nft}[NFT app on Github^].

== Fungible vs non-fungible tokens

[cols=",,",options="header",stripes="hover"]
|===
|
|Fungible tokens
|Non-fungible tokens


|Description
|Tokens that can be readily interchanged with each other.
| Each token has unique characteristics which make it special.

|Charactericitics
a|
* Not unique
* Divisible
* mutually interchangeable

a|
* Unique
* Indivisible
* Not mutually interchangeable

|Examples
a|
* Real world: Fiat currencies like the Dollar($) or Euro(€).
* Digital token: Bitcoin(BTC) or Lisk(LSK).
a|
* Real world: Paintings or music.
* Digital token: Crypto collectables(like Cryptokitties), event tickets or other virtual assets.
|===

== NFT blockchain overview

In our example, we will design the following characteristics for the blockchain application:

image:tutorials/nft.png[]

As the above image describes, we need to create the following components:

. The NFT module (on-chain)
.. Three new transaction assets for the NFT module
. The NFT plugin (off-chain)

Additional to the blockchain application, we will also implement **frontend application**, which allows us to interact with the blockchain applicationn through a UI in the browser.

:sectnums:

== Project setup

Create a new folder, which will contain all the files for the NFT app:

[source,bash]
----
mkdir nft
mkdir nft/blockchain-app
cd nft/blockchain-app
npm init --yes
npm i lisk-sdk
----

Next, create a new file `index.js` and paste the following:

.nft/blockchain-app/index.js
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');

const app = Application.defaultApplication(genesisBlockDevnet, configDevnet);

app
	.run()
	.then(() => app.logger.info('App started...'))
	.catch(error => {
		console.error('Faced error in application', error);
		process.exit(1);
	});
----

This code snippet creates a default blockchain application, which is configured for development purposes.
We will use this app as basis for the NFT app and extend it with a module and a plugin in the next steps, to suit the desire use case.

Create a new folder `nft-module/` and inside a new file `index.js`:

.nft/blockchain-app/
[source,bash]
----
mkdir nft-module
----

== Transaction assets

The user shall have the ability to create, purchase and transfer NFTs in the network.
To do this, we create the corresponding transaction assets for the NFT module.
These transaction assets each define the asset schema for the transaction data, and the logic, how this data is applied and stored in the database.


.nft/blockchain-app/nft-module/
[source,bash]
----
mkdir transactions <1>
cd transactions/
----

<1> Create a new folder `transactions/`, which will contain the files for the transaction assets.


=== CreateNFT asset

Create a new file `create_nft.js` inside the newly created `transactions/` folder.

Now open the file and paste the code below:

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset { <1>

}

module.exports = CreateNFTAsset; <2>
----

<1> Extend from the base asset to implement a custom asset.
<2> Export the asset, so it can be imported later into the custom module.

Now let's define all required properties for the transaction asset one after another.

==== Asset ID and name
.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT"; <1>
  id = 0; <2>
}

module.exports = CreateNFTAsset;
----

<1> Set the asset name to `"createNFT"`.
<2> Set the asset id to `1`.

==== Asset schema

The asset schema describes the required datatypes and the structure of the data in the respective transaction asset.

TIP: For more information how schemas are used in the application, check out the xref:{url_references_schemas}[] reference.

For creating a new NFT token, we require the following information:

* Name: The name of the NFT.
* Initial value: The inital value of the NFT.
* Minimal purchase margin: The % value of the initial value, that is added to the initial value when purchasing the NFT.

Therefore, create the schema like described below:

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT";
  id = 0;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/create",
    type: "object",
    required: ["minPurchaseMargin", "initValue", "name"],
    properties: {
      minPurchaseMargin: {
        dataType: "uint32",
        fieldNumber: 1,
      },
      initValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };
}

module.exports = CreateNFTAsset;
----

After we defined in the `schema` what data to expect, we now define how the data is applied on the blockchain in the `apply()` function.

==== NFT token related functions

For a better overview, create a new file `nft.js` in the `nft-module/` folder.

Now open `nft.js` and define the functions related to the NFT token, which will be used in the assets and the module in the next steps.

The following functions are implemtented:

* `registeredNFTTokensSchema`: The schema, how the NFTs are saved in the database.
* `CHAIN_STATE_NFT_TOKENS`: The key under which the NFTs are saved in the database.
* `createNFTToken()`: Creates a new NFT based on provided `name`, `ownerAddress`, `nonce`, `value` and  `minPurchaseMargin`.
* `setAllNFTTokens()`: Saves provided NFTs to the database.
* `getAllNFTTokens()`: Retrieves NFTs from the database.
* `getAllNFTTokensAsJSON()`: Returns all NFTs from the database as JSON.

[NOTE]
====
You might have spotted, that we use special parameters in the functions, like `stateStore` and `dataAccess`.
These variables are available in the module or plugin files, and are explained in more detail in the next section.
====

.nft/blockchain-app/nft-module/nft.js
[source,js]
----
const { codec, cryptography } = require("lisk-sdk");

const registeredNFTTokensSchema = {
  $id: "lisk/nft/registeredTokens",
  type: "object",
  required: ["registeredNFTTokens"],
  properties: {
    registeredNFTTokens: {
      type: "array",
      fieldNumber: 1,
      items: {
        type: "object",
        required: ["id", "value", "ownerAddress", "minPurchaseMargin", "name"],
        properties: {
          id: {
            dataType: "bytes",
            fieldNumber: 1,
          },
          value: {
            dataType: "uint64",
            fieldNumber: 2,
          },
          ownerAddress: {
            dataType: "bytes",
            fieldNumber: 3,
          },
          minPurchaseMargin: {
            dataType: "uint32",
            fieldNumber: 4,
          },
          name: {
            dataType: "string",
            fieldNumber: 5,
          },
        },
      },
    },
  },
};

const CHAIN_STATE_NFT_TOKENS = "nft:registeredNFTTokens";

const createNFTToken = ({ name, ownerAddress, nonce, value, minPurchaseMargin }) => {
  const nonceBuffer = Buffer.alloc(8);
  nonceBuffer.writeBigInt64LE(nonce);
  const seed = Buffer.concat([ownerAddress, nonceBuffer]);
  const id = cryptography.hash(seed);

  return {
    id,
    minPurchaseMargin,
    name,
    ownerAddress,
    value,
  };
};

const getAllNFTTokens = async (stateStore) => {
  const registeredTokensBuffer = await stateStore.chain.get(
    CHAIN_STATE_NFT_TOKENS
  );
  if (!registeredTokensBuffer) {
    return [];
  }

  const registeredTokens = codec.decode(
    registeredNFTTokensSchema,
    registeredTokensBuffer
  );

  return registeredTokens.registeredNFTTokens;
};

const getAllNFTTokensAsJSON = async (dataAccess) => {
  const registeredTokensBuffer = await dataAccess.getChainState(
    CHAIN_STATE_NFT_TOKENS
  );

  if (!registeredTokensBuffer) {
    return [];
  }

  const registeredTokens = codec.decode(
    registeredNFTTokensSchema,
    registeredTokensBuffer
  );

  return codec.toJSON(registeredNFTTokensSchema, registeredTokens)
    .registeredNFTTokens;
};

const setAllNFTTokens = async (stateStore, NFTTokens) => {
  const registeredTokens = {
    registeredNFTTokens: NFTTokens.sort((a, b) => a.id.compare(b.id)),
  };

  await stateStore.chain.set(
    CHAIN_STATE_NFT_TOKENS,
    codec.encode(registeredNFTTokensSchema, registeredTokens)
  );
};

module.exports = {
  registeredNFTTokensSchema,
  CHAIN_STATE_NFT_TOKENS,
  getAllNFTTokens,
  setAllNFTTokens,
  getAllNFTTokensAsJSON,
  createNFTToken,
};
----

==== The `validate()` function

Before the data in the transaction asset is applied in the next step, use the `validate()` function to verify the correctness of the submitted data.

The `validate()` function has access to:

* `asset`: the posted transaction asset.

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT";
  id = 0;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/create",
    type: "object",
    required: ["minPurchaseMargin", "initValue", "name"],
    properties: {
      minPurchaseMargin: {
        dataType: "uint32",
        fieldNumber: 1,
      },
      initValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };

  // verify if init value is > 0 <1>
  validate({asset}) {
    if (asset.initValue <= 0) {
      throw new Error("NFT init value is too low.");
    }
  };
}

module.exports = CreateNFTAsset;
----

<1> Verifies that the initial value of the NFT is greater than 0.
If not, the transaction is not applied, and a corresponding error is thrown.

==== The `apply()` function

The `apply()` function has access to:

* `asset`: the posted transaction asset.
* `stateStore`: The state store is a data structure that holds temporary state while processing a block.
It is used here to get and set certain data from and to the database.
* `reducerHandler`: Allows to use reducer functions of other modules inside the `apply()` function.
* `transaction`: the complete transaction object.

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");
const {
  getAllNFTTokens,
  setAllNFTTokens,
  createNFTToken,
} = require("../nft"); <1>

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT";
  id = 0;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/create",
    type: "object",
    required: ["minPurchaseMargin", "initValue", "name"],
    properties: {
      minPurchaseMargin: {
        dataType: "uint32",
        fieldNumber: 1,
      },
      initValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };

  // verify if init value is > 0
  validate({asset}) {
    if (asset.initValue <= 0) {
      throw new Error("NFT init value is too low.");
    }
  };

  async apply({ asset, stateStore, reducerHandler, transaction }) {
    // create NFT <2>
    const senderAddress = transaction.senderAddress;
    const senderAccount = await stateStore.account.get(senderAddress);
    const nftToken = createNFTToken({
      name: asset.name,
      ownerAddress: senderAddress,
      nonce: transaction.nonce,
      value: asset.initValue,
      minPurchaseMargin: asset.minPurchaseMargin,
    });

    // update sender account with unique NFT ID <3>
    senderAccount.nft.ownNFTs.push(nftToken.id);
    await stateStore.account.set(senderAddress, senderAccount);

    // debit tokens from sender account to create an NFT <4>
    await reducerHandler.invoke("token:debit", {
      address: senderAddress,
      amount: asset.initValue,
    });

    // save NFTs <5>
    const allTokens = await getAllNFTTokens(stateStore);
    allTokens.push(nftToken);
    await setAllNFTTokens(stateStore, allTokens);
  }
}

module.exports = CreateNFTAsset;
----

<1> Import `getAllNFTTokens`, `setAllNFTTokens` and `createNFTToken` fromt her `nft.js` file.
<2> Create the NFT based on the asset data and the sender address of the transaction.
<3> Push the ID of the newly created NFT into the sender account.
Save the updated sender account in the database.
<4> Debit the initial value of the NFT from the sender account.
<5> Push the newly created NFT into the list of all NFTs and save it in the database.

=== PurchaseNFT asset

Analog to the implementation of the `createNFT` asset, create the `purchaseNFT` asset by pasting the snippet below.

Create a new file `purchase_nft.js` inside the `transactions/` folder.

.nft/blockchain-app/nft-module/transactions/purchase_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");
const { getAllNFTTokens, setAllNFTTokens } = require("../nft");

// extend base asset to implement your custom asset
class PurchaseNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "purchaseNFT";
  id = 1;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/purchase",
    type: "object",
    required: ["nftId", "purchaseValue", "name"],
    properties: {
      nftId: {
        dataType: "bytes",
        fieldNumber: 1,
      },
      purchaseValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };

  async apply({ asset, stateStore, reducerHandler, transaction }) {
    const nftTokens = await getAllNFTTokens(stateStore);
    const nftTokenIndex = nftTokens.findIndex((t) => t.id.equals(asset.nftId));

    // verify if purchasing nft token exists <1>
    if (nftTokenIndex < 0) {
      throw new Error("Token id not found");
    }
    const token = nftTokens[nftTokenIndex];
    const tokenOwner = await stateStore.account.get(token.ownerAddress);
    const tokenOwnerAddress = tokenOwner.address;

    // verify if minimum nft purchasing condition met <2>
    if (token && token.minPurchaseMargin === 0) {
      throw new Error("This NFT token can not be purchased");
    }

    const tokenCurrentValue = token.value;
    const tokenMinPurchaseValue =
      tokenCurrentValue +
      (tokenCurrentValue * BigInt(token.minPurchaseMargin)) / BigInt(100);
    const purchaseValue = asset.purchaseValue;

    if (tokenMinPurchaseValue > purchaseValue) {
      throw new Error("Token can not be purchased on given value");
    }

    const purchaserAddress = transaction.senderAddress;
    const purchaserAccount = await stateStore.account.get(purchaserAddress);

    // remove nft token from owner account <3>
    const ownerTokenIndex = tokenOwner.nft.ownNFTs.findIndex((a) =>
      a.equals(token.id)
    );
    tokenOwner.nft.ownNFTs.splice(ownerTokenIndex, 1);
    await stateStore.account.set(tokenOwnerAddress, tokenOwner);

    // add nft token to purchaser account <4>
    purchaserAccount.nft.ownNFTs.push(token.id);
    await stateStore.account.set(purchaserAddress, purchaserAccount);

    token.ownerAddress = purchaserAddress;
    token.value = purchaseValue;
    nftTokens[nftTokenIndex] = token;
    await setAllNFTTokens(stateStore, nftTokens);

    // debit LSK tokens from purchaser account <5>
    await reducerHandler.invoke("token:debit", {
      address: purchaserAddress,
      amount: purchaseValue,
    });

    // credit LSK tokens to purchaser account <6>
    await reducerHandler.invoke("token:credit", {
      address: tokenOwnerAddress,
      amount: purchaseValue,
    });
  }
}

module.exports = PurchaseNFTAsset;
----

<1> description
<2> description
<3> description
<4> description
<5> description
<6> description

=== TransferNFT asset

== The NFT module

Inside the `nft-module/`, create a new file `index.js`.

Open `index.js` and create the skeleton, which will contain all parts of the NFT module:

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");

class NFTModule extends BaseModule { <1>

}

module.exports = { NFTModule }; <2>
----

<1> Extend from the base module to implement a custom module.
<2> Export the module, so it can be imported later into the application.

Now define all required properties for the module one after another.

=== Module ID and name
Let's start with the most easy ones: defining the module name and id.

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");

class NFTModule extends BaseModule {
  name = "nft"; <1>
  id = 1024; <2>
}

module.exports = { NFTModule };
----

<1> Set the module name to `"nft"`.
<2> Set the module id to `1024`.

You can choose any module name, but it has to bbe unique in the network.
Same goes for the ID, though the minimum value for it is `1024`, as the other IDs are reserved for future default modules of the Lisk SDK.

=== The account schema
Next, define the account schema.
This property defines the properties, that are added to each network account by the module, if it is registered with the application later.

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");

// Extend base module to implement your custom module
class NFTModule extends BaseModule {
  name = "nft";
  id = 1024;
  accountSchema = {
    type: "object",
    required: ["ownNFTs"],
    properties: {
      ownNFTs: {
        type: "array",
        fieldNumber: 4,
        items: {
          dataType: "bytes",
        },
      },
    },
    default: {
      ownNFTs: [],
    },
  };
}

module.exports = { NFTModule };

----
=== Importing transaction assets into the module
.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");
const { getAllNFTTokensAsJSON } = require("./nft");

const CreateNFT = require("./transactions/create_nft");
const PurchaseNFT = require("./transactions/purchase_nft");

// Extend base module to implement your custom module
class NFTModule extends BaseModule {
  name = "nft";
  id = 1024;
  accountSchema = {
    type: "object",
    required: ["ownNFTs"],
    properties: {
      ownNFTs: {
        type: "array",
        fieldNumber: 4,
        items: {
          dataType: "bytes",
        },
      },
    },
    default: {
      ownNFTs: [],
    },
  };
  transactionAssets = [new CreateNFT(), new PurchaseNFT()];
}

module.exports = { NFTModule };

----
=== Actions
.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");
const { getAllNFTTokensAsJSON } = require("./nft");

const CreateNFT = require("./transactions/create_nft");
const PurchaseNFT = require("./transactions/purchase_nft");

// Extend base module to implement your custom module
class NFTModule extends BaseModule {
  name = "nft";
  id = 1024;
  accountSchema = {
    type: "object",
    required: ["ownNFTs"],
    properties: {
      ownNFTs: {
        type: "array",
        fieldNumber: 4,
        items: {
          dataType: "bytes",
        },
      },
    },
    default: {
      ownNFTs: [],
    },
  };
  transactionAssets = [new CreateNFT(), new PurchaseNFT()];
  actions = {
    // get all the registered NFT tokens from blockchain
    getAllNFTTokens: async () => getAllNFTTokensAsJSON(this._dataAccess),
  };
}

module.exports = { NFTModule };

----

== The NFT plugin

== Frontend application
