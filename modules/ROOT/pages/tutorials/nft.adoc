= Non-fungible token (NFT)
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc:
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:experimental:
// External URLs
:url_github_nft: https://github.com/LiskHQ/lisk-sdk-examples/tree/development/tutorials/nft
:url_react_docs: https://reactjs.org/docs/getting-started.html
// Project URLs
:url_references_schemas: references/schemas.adoc
:url_references_token_module: token-module.adoc

In the NFT tutorial, you learn step-by-step how to create modules and plugins which add the feature to create and purchase NFTs to a blockchain application.

TIP: For the *full code example* please see {url_github_nft}[NFT app on Github^].

== Fungible vs non-fungible tokens

[cols=",,",options="header",stripes="hover"]
|===
|
|Fungible tokens
|Non-fungible tokens


|Description
|Tokens that can be readily interchanged with each other.
|Each token has unique characteristics which make it special.

|Charactericitics
a|
* Not unique
* Divisible
* Mutually interchangeable

a|
* Unique
* Indivisible
* Not mutually interchangeable

|Examples
a|
* Real world: Fiat currencies like the Dollar($) or Euro(€).
* Digital token: Bitcoin(BTC) or Lisk(LSK).
a|
* Real world: Paintings or music.
* Digital token: Crypto collectables(like Cryptokitties), event tickets or other virtual assets.
|===

== NFT blockchain overview

In our example, we will design the following characteristics for the blockchain application:

image:tutorials/nft/nft.png[]

As the above image describes, we need to create the following components:

. The NFT module (on-chain)
.. Three new transaction assets for the NFT module
. The NFT plugin (off-chain)

Additional to the blockchain application, we will also implement **frontend application**, which allows us to interact with the blockchain applicationn through a UI in the browser.

:sectnums:

== Project setup

Create a new folder, which will contain all the files for the NFT app:

[source,bash]
----
mkdir nft
mkdir nft/blockchain-app
cd nft/blockchain-app
npm init --yes
npm i lisk-sdk
----

Next, create a new file `index.js` and paste the following:

.nft/blockchain-app/index.js
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');

const app = Application.defaultApplication(genesisBlockDevnet, configDevnet);

app
	.run()
	.then(() => app.logger.info('App started...'))
	.catch(error => {
		console.error('Faced error in application', error);
		process.exit(1);
	});
----

This code snippet creates a default blockchain application, which is configured for development purposes.
We will use this app as basis for the NFT app and extend it with a module and a plugin in the next steps, to suit the desired use case.

Create a new folder `nft-module/` and inside a new file `index.js`:

.nft/blockchain-app/
[source,bash]
----
mkdir nft-module
----

== NFT related functions

For a better overview, create a new file `nft.js` in the `nft-module/` folder.

Now open `nft.js` and define the functions related to the NFT, which will be used in the assets and the module in the next steps.

The following functions are implemtented:

* `registeredNFTTokensSchema`: The schema, how the NFTs are saved in the database.
Each NFT has the following properties:
** id
** value
** ownerAddress
** minPurchaseMargin
** name
* `CHAIN_STATE_NFT_TOKENS`: The key under which the NFTs are saved in the database.
* `createNFTToken()`: Creates a new NFT based on provided `name`, `ownerAddress`, `nonce`, `value` and  `minPurchaseMargin`.
The ID for the NFT is created by combining and hashing the owner address and its' current nonce, which in combination always creates a unique value.
This way it is ensured that each newly created NFT has a unique ID in the database.
* `setAllNFTTokens()`: Saves provided NFTs to the database.
* `getAllNFTTokens()`: Retrieves NFTs from the database.
* `getAllNFTTokensAsJSON()`: Returns all NFTs from the database as JSON.

[NOTE]
====
You might have spotted, that we use special parameters in the functions, like `stateStore` and `dataAccess`.
These variables are available in the module or plugin files, and are explained in more detail in the next sections.
====

.nft/blockchain-app/nft-module/nft.js
[source,js]
----
const { codec, cryptography } = require("lisk-sdk");

const registeredNFTTokensSchema = {
  $id: "lisk/nft/registeredTokens",
  type: "object",
  required: ["registeredNFTTokens"],
  properties: {
    registeredNFTTokens: {
      type: "array",
      fieldNumber: 1,
      items: {
        type: "object",
        required: ["id", "value", "ownerAddress", "minPurchaseMargin", "name"],
        properties: {
          id: {
            dataType: "bytes",
            fieldNumber: 1,
          },
          value: {
            dataType: "uint64",
            fieldNumber: 2,
          },
          ownerAddress: {
            dataType: "bytes",
            fieldNumber: 3,
          },
          minPurchaseMargin: {
            dataType: "uint32",
            fieldNumber: 4,
          },
          name: {
            dataType: "string",
            fieldNumber: 5,
          },
        },
      },
    },
  },
};

const CHAIN_STATE_NFT_TOKENS = "nft:registeredNFTTokens";

const createNFTToken = ({ name, ownerAddress, nonce, value, minPurchaseMargin }) => {
  const nonceBuffer = Buffer.alloc(8);
  nonceBuffer.writeBigInt64LE(nonce);
  // Create a unique seed by using a combination of the owner account address and the current nonce of the account.
  const seed = Buffer.concat([ownerAddress, nonceBuffer]);
  const id = cryptography.hash(seed);

  return {
    id,
    minPurchaseMargin,
    name,
    ownerAddress,
    value,
  };
};

const getAllNFTTokens = async (stateStore) => {
  const registeredTokensBuffer = await stateStore.chain.get(
    CHAIN_STATE_NFT_TOKENS
  );
  if (!registeredTokensBuffer) {
    return [];
  }

  const registeredTokens = codec.decode(
    registeredNFTTokensSchema,
    registeredTokensBuffer
  );

  return registeredTokens.registeredNFTTokens;
};

const getAllNFTTokensAsJSON = async (dataAccess) => {
  const registeredTokensBuffer = await dataAccess.getChainState(
    CHAIN_STATE_NFT_TOKENS
  );

  if (!registeredTokensBuffer) {
    return [];
  }

  const registeredTokens = codec.decode(
    registeredNFTTokensSchema,
    registeredTokensBuffer
  );

  return codec.toJSON(registeredNFTTokensSchema, registeredTokens)
    .registeredNFTTokens;
};

const setAllNFTTokens = async (stateStore, NFTTokens) => {
  const registeredTokens = {
    registeredNFTTokens: NFTTokens.sort((a, b) => a.id.compare(b.id)),
  };

  await stateStore.chain.set(
    CHAIN_STATE_NFT_TOKENS,
    codec.encode(registeredNFTTokensSchema, registeredTokens)
  );
};

module.exports = {
  registeredNFTTokensSchema,
  CHAIN_STATE_NFT_TOKENS,
  getAllNFTTokens,
  setAllNFTTokens,
  getAllNFTTokensAsJSON,
  createNFTToken,
};
----

== Transaction assets

The user shall have the ability to create, purchase and transfer NFTs in the network.
To do this, we create the corresponding transaction assets for the NFT module.
These transaction assets each define both, the asset schema for the transaction data, and the logic, how this data is applied and stored in the database.


.nft/blockchain-app/nft-module/
[source,bash]
----
mkdir transactions <1>
cd transactions/
----

<1> Create a new folder `transactions/`, which will contain the files for the transaction assets.

=== CreateNFT asset

Create a new file `create_nft.js` inside the newly created `transactions/` folder.

Now open the file and paste the code below:

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset { <1>

}

module.exports = CreateNFTAsset; <2>
----

<1> Extend from the base asset to implement a custom asset.
<2> Export the asset, so it can be imported later into the custom module.

Now define all required properties for the transaction asset one after another.

==== Asset ID and name
.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT"; <1>
  id = 0; <2>
}

module.exports = CreateNFTAsset;
----

<1> Set the asset name to `"createNFT"`.
<2> Set the asset id to `1`.

==== Asset schema

The asset schema describes the required datatypes and the structure of the data in the respective transaction asset.

TIP: For more information how schemas are used in the application, check out the xref:{url_references_schemas}[] reference.

For creating a new NFT, we require the following information:

* Name: The name of the NFT.
* Initial value: The inital value of the NFT.
* Minimal purchase margin: The % value of the initial value, that is added to the initial value when purchasing the NFT.

Therefore, create the schema like described below:

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT";
  id = 0;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/create",
    type: "object",
    required: ["minPurchaseMargin", "initValue", "name"],
    properties: {
      minPurchaseMargin: {
        dataType: "uint32",
        fieldNumber: 1,
      },
      initValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };
}

module.exports = CreateNFTAsset;
----

Now that the `schema` defines what data to expect, we can use the `validate()` function to validate the received data of the transaction asset before applying it.

==== The `validate()` function

Before the data in the transaction asset is applied in the next step, use the `validate()` function to verify the correctness of the submitted data.

The `validate()` function has access to:

* `asset`: the posted transaction asset.

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT";
  id = 0;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/create",
    type: "object",
    required: ["minPurchaseMargin", "initValue", "name"],
    properties: {
      minPurchaseMargin: {
        dataType: "uint32",
        fieldNumber: 1,
      },
      initValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };

  // verify if init value is > 0 <1>
  validate({asset}) {
    if (asset.initValue <= 0) {
      throw new Error("NFT init value is too low.");
    }
  };
}

module.exports = CreateNFTAsset;
----

<1> Verifies that the initial value of the NFT is greater than 0.
If not, the transaction is not applied, and a corresponding error is thrown.

==== The `apply()` function

The `apply()` function has access to:

* `asset`: the posted transaction asset.
* `stateStore`: The state store is a data structure that holds temporary state while processing a block.
It is used here to get and set certain data from and to the database.
* `reducerHandler`: Allows to use reducer functions of other modules inside the `apply()` function.
* `transaction`: the complete transaction object.

.nft/blockchain-app/nft-module/transactions/create_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");
const {
  getAllNFTTokens,
  setAllNFTTokens,
  createNFTToken,
} = require("../nft"); <1>

// extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "createNFT";
  id = 0;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/create",
    type: "object",
    required: ["minPurchaseMargin", "initValue", "name"],
    properties: {
      minPurchaseMargin: {
        dataType: "uint32",
        fieldNumber: 1,
      },
      initValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };

  // verify if init value is > 0
  validate({asset}) {
    if (asset.initValue <= 0) {
      throw new Error("NFT init value is too low.");
    }
  };

  async apply({ asset, stateStore, reducerHandler, transaction }) {
    // create NFT <2>
    const senderAddress = transaction.senderAddress;
    const senderAccount = await stateStore.account.get(senderAddress);
    const nftToken = createNFTToken({
      name: asset.name,
      ownerAddress: senderAddress,
      nonce: transaction.nonce,
      value: asset.initValue,
      minPurchaseMargin: asset.minPurchaseMargin,
    });

    // update sender account with unique NFT ID <3>
    senderAccount.nft.ownNFTs.push(nftToken.id);
    await stateStore.account.set(senderAddress, senderAccount);

    // debit tokens from sender account to create an NFT <4>
    await reducerHandler.invoke("token:debit", {
      address: senderAddress,
      amount: asset.initValue,
    });

    // save NFTs <5>
    const allTokens = await getAllNFTTokens(stateStore);
    allTokens.push(nftToken);
    await setAllNFTTokens(stateStore, allTokens);
  }
}

module.exports = CreateNFTAsset;
----

<1> Import `getAllNFTTokens`, `setAllNFTTokens` and `createNFTToken` fromt her `nft.js` file.
<2> Create the NFT based on the asset data and the sender address of the transaction.
<3> Push the ID of the newly created NFT into the sender account.
Save the updated sender account in the database.
<4> Debit the initial value of the NFT from the sender account.
<5> Push the newly created NFT into the list of all NFTs and save it in the database.

=== PurchaseNFT asset

Create a new file `purchase_nft.js` inside the `transactions/` folder.

Analog to the implementation of the `createNFT` asset, create the `purchaseNFT` asset by pasting the snippet below.

.nft/blockchain-app/nft-module/transactions/purchase_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");
const { getAllNFTTokens, setAllNFTTokens } = require("../nft");

// extend base asset to implement your custom asset
class PurchaseNFTAsset extends BaseAsset {
  // define unique asset name and id
  name = "purchaseNFT";
  id = 1;
  // define asset schema for serialization
  schema = {
    $id: "lisk/nft/purchase",
    type: "object",
    required: ["nftId", "purchaseValue", "name"],
    properties: {
      nftId: {
        dataType: "bytes",
        fieldNumber: 1,
      },
      purchaseValue: {
        dataType: "uint64",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };

  async apply({ asset, stateStore, reducerHandler, transaction }) {
    // verify if purchasing nft exists <1>
    const nftTokens = await getAllNFTTokens(stateStore);
    const nftTokenIndex = nftTokens.findIndex((t) => t.id.equals(asset.nftId));

    if (nftTokenIndex < 0) {
      throw new Error("Token id not found");
    }
    // verify if minimum nft purchasing condition met <2>
    const token = nftTokens[nftTokenIndex];
    const tokenOwner = await stateStore.account.get(token.ownerAddress);
    const tokenOwnerAddress = tokenOwner.address;

    if (token && token.minPurchaseMargin === 0) {
      throw new Error("This NFT can not be purchased");
    }

    const tokenCurrentValue = token.value;
    const tokenMinPurchaseValue =
      tokenCurrentValue +
      (tokenCurrentValue * BigInt(token.minPurchaseMargin)) / BigInt(100);
    const purchaseValue = asset.purchaseValue;

    if (tokenMinPurchaseValue > purchaseValue) {
      throw new Error("Token can not be purchased value is too low. Minimum value: " + tokenMinPurchaseValue);
    }

    // remove nft from owner account <3>
    const purchaserAddress = transaction.senderAddress;
    const purchaserAccount = await stateStore.account.get(purchaserAddress);

    const ownerTokenIndex = tokenOwner.nft.ownNFTs.findIndex((a) =>
      a.equals(token.id)
    );
    tokenOwner.nft.ownNFTs.splice(ownerTokenIndex, 1);
    await stateStore.account.set(tokenOwnerAddress, tokenOwner);

    // add nft to purchaser account <4>
    purchaserAccount.nft.ownNFTs.push(token.id);
    await stateStore.account.set(purchaserAddress, purchaserAccount);

    token.ownerAddress = purchaserAddress;
    token.value = purchaseValue;
    nftTokens[nftTokenIndex] = token;
    await setAllNFTTokens(stateStore, nftTokens);

    // debit LSK tokens from purchaser account <5>
    await reducerHandler.invoke("token:debit", {
      address: purchaserAddress,
      amount: purchaseValue,
    });

    // credit LSK tokens to purchaser account <6>
    await reducerHandler.invoke("token:credit", {
      address: tokenOwnerAddress,
      amount: purchaseValue,
    });
  }
}

module.exports = PurchaseNFTAsset;
----

<1> First verify, that the NFT which is purchased exists in the database.
To do this, we request all NFTs with `getAllNFTTokens()` and search inside the returned list for the desired NFT ID.
If no NFT is found, a corresponding error is thrown.
<2> If the NFT was found, it is retrieved from the database, and the minimum purchase value of the token is compared to the purchase value in the transaction asset.
If the purchase value in the transaction asset is equal or higher than the minimal purchase value of the NFT, the NFT can be purchased.
Otherwise, an error will be thrown.
<3> Next, it is needed to remove the NFT from the current owner account.
The `StateStore` is used here to retrieve the owner account data from the database and later to update the owner account in the database, after the token ID has been removed from their owned tokens.
<4> Next, we add the NFT to the account of the purchaser.
The `StateStore` is used again to update the purchaser account in the database, after the token ID has been added to their owned tokens.
<5> Now we need to debit the purchase value from the purchasers account.
We use here the `reducerHandler` and invoke `token:debit` from xref:{url_references_token_module}[] which allows to conveniently debit tokens from an account.
<6> Finally we need to credit the purchase value to the owners account.
We use here the `reducerHandler` and invoke `token:debit` from xref:{url_references_token_module}[] which allows to conveniently credit tokens to an account.

=== TransferNFT asset
The last transaction asset that we want to implement in this tutorial is the `transferNFT` transaction.

Create a new file `transfer_nft.js` inside the `transactions/` folder.
Create the `transferNFT` asset by pasting the snippet below.

.nft/blockchain-app/nft-module/transactions/transfer_nft.js
[source,js]
----
const { BaseAsset } = require("lisk-sdk");
const { getAllNFTTokens, setAllNFTTokens } = require("../nft_token");

// 1.extend base asset to implement your custom asset
class TransferNFTAsset extends BaseAsset {
  // 2.define unique asset name and id
  name = "transferNFT";
  id = 2;
  // 3.define asset schema for serialization
  schema = {
    $id: "lisk/nft/transfer",
    type: "object",
    required: ["nftId", "recipient"],
    properties: {
      nftId: {
        dataType: "bytes",
        fieldNumber: 1,
      },
      recipient: {
        dataType: "bytes",
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        fieldNumber: 3,
      },
    },
  };

  async apply({ asset, stateStore, reducerHandler, transaction }) {
    const nftTokens = await getAllNFTTokens(stateStore);
    const nftTokenIndex = nftTokens.findIndex((t) => t.id.equals(asset.nftId));

    // 4.verify if the nft exists <1>
    if (nftTokenIndex < 0) {
      throw new Error("Token id not found");
    }
    const token = nftTokens[nftTokenIndex];
    const tokenOwnerAddress = token.ownerAddress;
    const senderAddress = transaction.senderAddress;
    // 5.verify that the sender owns the nft <2>

    if (!tokenOwnerAddress.equals(senderAddress)) {
      throw new Error("An NFT can only be transferred by the owner of the NFT.");
    }

    const tokenOwner = await stateStore.account.get(tokenOwnerAddress);
    // 6.remove nft from the owner account <3>
    const ownerTokenIndex = tokenOwner.nft.ownNFTs.findIndex((a) =>
      a.equals(token.id)
    );
    tokenOwner.nft.ownNFTs.splice(ownerTokenIndex, 1);
    await stateStore.account.set(tokenOwnerAddress, tokenOwner);

    // 7.add nft to the recipient account <4>
    const recipientAddress = asset.recipient;
    const recipientAccount = await stateStore.account.get(recipientAddress);
    recipientAccount.nft.ownNFTs.push(token.id);
    await stateStore.account.set(recipientAddress, recipientAccount);

    token.ownerAddress = recipientAddress;
    nftTokens[nftTokenIndex] = token;
    await setAllNFTTokens(stateStore, nftTokens);
  }
}

module.exports = TransferNFTAsset;
----

<1> First verify, that the NFT which is purchased exists in the database.
To do this, we request all NFTs with `getAllNFTTokens()` and search inside the returned list for the desired NFT ID.
If no NFT is found, a corresponding error is thrown.
<2> Next verify, that the account who wants to transfer the NFT actually owns the NFT.
<3> Next, it is needed to remove the NFT from the current owner account.
The `StateStore` is used here to retrieve the owner account data from the database and later to update the owner account in the database, after the token ID has been removed from their owned tokens.
<4> Next, we add the NFT to the account of the recipient.
The `StateStore` is used again to update the recipient account in the database, after the token ID has been added to their owned tokens.

== The NFT module

Inside the `nft-module/`, create a new file `index.js`.

Open `index.js` and create the skeleton, which will contain all parts of the NFT module:

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");

class NFTModule extends BaseModule { <1>

}

module.exports = { NFTModule }; <2>
----

<1> Extend from the base module to implement a custom module.
<2> Export the module, so it can be imported later into the application.

Now define all required properties for the module one after another.

=== Module ID and name
Let's start with the most easy ones: defining the module name and id.

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");

class NFTModule extends BaseModule {
  name = "nft"; <1>
  id = 1024; <2>
}

module.exports = { NFTModule };
----

<1> Set the module name to `"nft"`.
<2> Set the module id to `1024`.

You can choose any module name, but it has to be unique in the network.
Same goes for the ID, though the minimum value for it is `1024`, as the other IDs are reserved for future default modules of the Lisk SDK.

=== The account schema
Next, define the account schema.
This property defines the properties, that are added to each network account by the module, if it is registered with the application later.

Here, we expect each account to have a property `ownNFTs`, which is an array of NFTs which the account owns.
By default, it is empty.

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");

// Extend base module to implement your custom module
class NFTModule extends BaseModule {
  name = "nft";
  id = 1024;
  accountSchema = {
    type: "object",
    required: ["ownNFTs"],
    properties: {
      ownNFTs: {
        type: "array",
        fieldNumber: 4,
        items: {
          dataType: "bytes",
        },
      },
    },
    default: {
      ownNFTs: [],
    },
  };
}

module.exports = { NFTModule };

----

=== Importing transaction assets into the module

Now let's import the transactions which were created in section 2: <<transaction-assets>> into the module.

Add them to the `tansactionAssets` property like shown in the snippet below:

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");
const { getAllNFTTokensAsJSON } = require("./nft");

const CreateNFT = require("./transactions/create_nft");
const PurchaseNFT = require("./transactions/purchase_nft");
const TransferNFT = require("./transactions/transfer_nft");

// Extend base module to implement your custom module
class NFTModule extends BaseModule {
  name = "nft";
  id = 1024;
  accountSchema = {
    type: "object",
    required: ["ownNFTs"],
    properties: {
      ownNFTs: {
        type: "array",
        fieldNumber: 4,
        items: {
          dataType: "bytes",
        },
      },
    },
    default: {
      ownNFTs: [],
    },
  };
  // Add the transaction assets to the module
  transactionAssets = [new CreateNFT(), new PurchaseNFT(), new TransferNFT()];
}

module.exports = { NFTModule };

----

=== Actions

As a last feature for the NFT module, we create an action `getAllNFTTokens` which will allow the NFT plugin later to retrieve a list of all existing NFT tokens.

To implement it, we use the function `getAllNFTTokensAsJSON()`, which has been described in section <<nft-related-functions>>.

.nft/blockchain-app/nft-module/index.js
[source,js]
----
const { BaseModule } = require("lisk-sdk");
const { getAllNFTTokensAsJSON } = require("./nft");

const CreateNFT = require("./transactions/create_nft");
const PurchaseNFT = require("./transactions/purchase_nft");

// Extend base module to implement your custom module
class NFTModule extends BaseModule {
  name = "nft";
  id = 1024;
  accountSchema = {
    type: "object",
    required: ["ownNFTs"],
    properties: {
      ownNFTs: {
        type: "array",
        fieldNumber: 4,
        items: {
          dataType: "bytes",
        },
      },
    },
    default: {
      ownNFTs: [],
    },
  };
  transactionAssets = [new CreateNFT(), new PurchaseNFT()];
  actions = {
    // get all the registered nfts from blockchain
    getAllNFTTokens: async () => getAllNFTTokensAsJSON(this._dataAccess),
  };
}

module.exports = { NFTModule };

----

== The NFT plugin

Now that all on-chain logic for the NFTs is defined in the NFT module, let's add a corresponding NFT plugin, which will handle the off-chain logic for the NFT app.

The NFT plugin shall provide a HTTP API which offers new endpoints for NFT related data from the blockchain.

Move out of the `nft-module` folder back into the `blockchain-app` folder.
Create a new folder `nft-api-plugin/`.

Inside the `nft-api-plugin/` folder, create a new file `index.js`.

.nft/blockchain-app/
[source,bash]
----
mkdir nft-api-plugin
touch nft-api-plugin/index.js
----

Open `index.js` and create the skeleton, which will contain all parts of the NFT plugin:

.nft/blockchain-app/nft-api-plugin/index.js
[source,js]
----
const { BasePlugin } = require("lisk-sdk");
const pJSON = require("../package.json");

class NFTAPIPlugin extends BasePlugin { <1>
  _server = undefined;
  _app = undefined;
  _channel = undefined;
  _db = undefined;
  _nodeInfo = undefined;

  static get alias() { <2>
    return "NFTHttpApi";
  }

  static get info() { <3>
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }

  get defaults() {
    return {};
  }

  get events() {
    return [];
  }

  get actions() {
    return {};
  }
}

module.exports = { NFTAPIPlugin }; <4>
----

<1> Extend from the base plugin to implement a custom plugin.
<2> Set the alias for the plugin to `NFTHttpApi`.
<3> Set the meta information for the plugin.
Here, we use the data from the `package.json` file.
<4> Export the plugin, so it can be imported later into the application.

=== Database related functions
For a better overview, first create another file which will contain the functions related to the plugin database.
Here, we use a key-value store to save the data, similar to how the on-chain related data is saved in the default key-value store of the blockchain application.

Create a new file `db.js`.
Paste the below snippet into the newly created file `db.js`.

`db.js` contains various functions that take care of the following aspects:

* `getDBInstance(dataPath,dbName)`: Creates a new key-value store `nft_plugin.db` for the NFT plugin.
The key-value store is used to store NFT related blockchain information of the plugin in a schema that makes it conveniently accessible for third party services.
* `saveTransactions(db, payload)`: Saves new transactions to the DB.
* `getAllTransactions(db, registeredSchema)`: Returns a list of all transactions from the DB.
* `getNFTHistory(db, dbKey)`: Returns the owner history of an NFT.
* `saveNFTHistory(db, decodedBlock, registeredModules)`: Filters for transactions of the NFT module in the decoded block.
Updates the NFT history based on the found NFT transaction in the block.
Saves the individual owner history for the corresponding NFTs in the database.

.nft/blockchain-app/nft-api-plugin/db.js
[source,js]
----
const fs_extra = require("fs-extra");
const os = require("os");
const path = require("path");
const { cryptography, codec, db } = require("lisk-sdk");

const DB_KEY_TRANSACTIONS = "nft:transactions"; <1>

// Schemas
const encodedTransactionSchema = { <2>
  $id: 'nft/encoded/transactions',
  type: 'object',
  required: ['transactions'],
  properties: {
    transactions: {
      type: 'array',
      fieldNumber: 1,
      items: {
        dataType: 'bytes',
      },
    },
  },
};

const encodedNFTHistorySchema = { <3>
  $id: 'nft/encoded/nftHistory',
  type: 'object',
  required: ['nftHistory'],
  properties: {
    nftHistory: {
      type: 'array',
      fieldNumber: 1,
      items: {
        dataType: 'bytes',
      },
    },
  },
};

const getDBInstance = async (dataPath = '~/.lisk/nft-app/', dbName = 'nft_plugin.db') => {
  const dirPath = path.join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);
  await fs_extra.ensureDir(dirPath);
  return new db.KVStore(dirPath);
};

const saveTransactions = async (db, payload) => {
  const savedTransactions = await getTransactions(db);
  const transactions = [...savedTransactions, ...payload];
  const encodedTransactions = codec.encode(encodedTransactionSchema, { transactions });
  await db.put(DB_KEY_TRANSACTIONS, encodedTransactions);
};

const getTransactions = async (db) => {
  try {
    const encodedTransactions = await db.get(DB_KEY_TRANSACTIONS);
    const { transactions } = codec.decode(encodedTransactionSchema, encodedTransactions);
    return transactions;
  }
  catch (error) {
    return [];
  }
};

const getAllTransactions = async (db, registeredSchema) => {
  const savedTransactions = await getTransactions(db);
  const transactions = [];
  for (const trx of savedTransactions) {
    transactions.push(decodeTransaction(trx, registeredSchema));
  }
  return transactions;
};

const getNFTHistory = async (db, dbKey) => {
  try {
    const encodedNFTHistory = await db.get(dbKey);
    const { nftHistory } = codec.decode(encodedNFTHistorySchema, encodedNFTHistory);

    return nftHistory;
  }
  catch (error) {
    return [];
  }
};

const saveNFTHistory = async (db, decodedBlock, registeredModules) => {
  decodedBlock.payload.map(async trx => {
    const module = registeredModules.find(m => m.id === trx.moduleID);
    if (module.name === 'nft') {
      const dbKey = `nft/${trx.asset.nftId}`; <4>
      const base32Address = cryptography.getBase32AddressFromPublicKey(Buffer.from(trx.senderPublicKey, 'hex'), 'lsk');
      const savedHistory = await getNFTHistory(db, dbKey);
      const nftHistory = [Buffer.from(base32Address, 'binary'), ...savedHistory];
      const encodedNFTHistory = codec.encode(encodedNFTHistorySchema, { nftHistory });
      await db.put(dbKey, encodedNFTHistory);
    }
  });
};

const decodeTransaction = (
  encodedTransaction,
  registeredSchema,
) => {
  const transaction = codec.decode(registeredSchema.transaction, encodedTransaction);
  const assetSchema = getTransactionAssetSchema(transaction, registeredSchema);
  const asset = codec.decode(assetSchema, transaction.asset);
  const id = cryptography.hash(encodedTransaction);
  return {
    ...codec.toJSON(registeredSchema.transaction, transaction),
    asset: codec.toJSON(assetSchema, asset),
    id: id.toString('hex'),
  };
};

const getTransactionAssetSchema = (
  transaction,
  registeredSchema,
) => {
  const txAssetSchema = registeredSchema.transactionsAssets.find(
    assetSchema =>
      assetSchema.moduleID === transaction.moduleID && assetSchema.assetID === transaction.assetID,
  );
  if (!txAssetSchema) {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `ModuleID: ${transaction.moduleID} AssetID: ${transaction.assetID} is not registered.`,
    );
  }
  return txAssetSchema.schema;
};

module.exports = {
  getDBInstance,
  getAllTransactions,
  getTransactions,
  saveTransactions,
  saveNFTHistory,
  getNFTHistory,
}
----


<1> `DB_KEY_TRANSACTIONS`: The key we use to save the transactions in the key-value store.
<2> `encodedTransactionSchema`: The schema how the transactions will be saved in the key-value store.
Here, we define a simple array which contains the encoded transactions.
<3> `encodedNFTHistorySchema`: The schema how the owner history of an NFT is saved in the key-value store
Here, we define a simple array, which contains the adresses of the current and all previous owners of the NFT.
<4> `dbKey`: The key we use to save the owner history of a NFT in the key-value store.

=== The plugin logic

Now go back to `index.js` and implement the desired plugin logic.

The plugin shall provide the following additional data to the application:

* a list of all existing NFTs and their corresponding owner history.
* details of an NFT including the owner history, by NFT ID.
* a list of all transactions, including their module and asset IDs and the transaction asset.

To create this data, the plugin needs to listen to events for new blocks in the blockchain application.
When a new block is created, the plugin checks if the block contains transactions and if so, saves them in the key-value store of the plugin.
In case the block contains transactions of the NFT module, it will also update the owner history of the NFTs in the key-value store.

We will then create an HTTP server and create the required API endpoints to serve the data to the frontend application.

We define all of this inside of the `load()` function.
All code inside the `load()` function is executed by the blockchain application when it loads the plugin.

The code in the `unload()` function is executed in complement by the blockchain application when it unloads the plugin.

.nft/blockchain-app/nft-api-plugin/index.js
[source,js]
----
const express = require("express");
const cors = require("cors");
const { BasePlugin, codec } = require("lisk-sdk");
const pJSON = require("../package.json");
const { getDBInstance, getNFTHistory, getAllTransactions, saveNFTHistory, saveTransactions } = require("./db");

// 1.plugin can be a daemon/HTTP/Websocket service for off-chain processing
class NFTAPIPlugin extends BasePlugin {
  _server = undefined;
  _app = undefined;
  _channel = undefined;
  _db = undefined;
  _nodeInfo = undefined;

  static get alias() {
    return "NFTHttpApi";
  }

  static get info() {
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }

  get defaults() {
    return {};
  }

  get events() {
    return [];
  }

  get actions() {
    return {};
  }

  async load(channel) {
    this._app = express();
    this._channel = channel;
    this._db = await getDBInstance();
    this._nodeInfo = await this._channel.invoke("app:getNodeInfo");


    this._app.use(cors({ origin: "*", methods: ["GET", "POST", "PUT"] }));
    this._app.use(express.json());

    this._app.get("/api/nft_tokens", async (_req, res) => {
      const nftTokens = await this._channel.invoke("nft:getAllNFTTokens");
      const data = await Promise.all(nftTokens.map(async token => {
        const dbKey = `${token.name}`;
        let tokenHistory = await getNFTHistory(this._db, dbKey);
        tokenHistory = tokenHistory.map(h => h.toString('binary'));
        return {
          ...token,
          tokenHistory,
        }
      }));

      res.json({ data });
    });

    this._app.get("/api/nft_tokens/:id", async (req, res) => {
      const nftTokens = await this._channel.invoke("nft:getAllNFTTokens");
      const token = nftTokens.find((t) => t.id === req.params.id);
      const dbKey = `${token.name}`;
      let tokenHistory = await getNFTHistory(this._db, dbKey);
      tokenHistory = tokenHistory.map(h => h.toString('binary'));

      res.json({ data: { ...token, tokenHistory } });
    });

    this._app.get("/api/transactions", async (_req, res) => {
      const transactions = await getAllTransactions(this._db, this.schemas);

      const data = transactions.map(trx => {
        const module = this._nodeInfo.registeredModules.find(m => m.id === trx.moduleID);
        const asset = module.transactionAssets.find(a => a.id === trx.assetID);
        return {
          ...trx,
          ...trx.asset,
          moduleName: module.name,
          assetName: asset.name,
        }
      })
      res.json({ data });
    });

    this._subscribeToChannel();

    this._server = this._app.listen(8080, "0.0.0.0");
  }

  _subscribeToChannel() {
    // listen to application events and enrich blockchain data for UI/third party application
    this._channel.subscribe('app:block:new', async (data) => {
      const { block } = data;
      const { payload } = codec.decode(
        this.schemas.block,
        Buffer.from(block, 'hex'),
      );
      if (payload.length > 0) {
        await saveTransactions(this._db, payload);
        const decodedBlock = this.codec.decodeBlock(block);
        // save NFT transaction history
        await saveNFTHistory(this._db, decodedBlock, this._nodeInfo.registeredModules);
      }
    });
  }

  async unload() {
    // close http server
    await new Promise((resolve, reject) => {
      this._server.close((err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
    // close database connection
    await this._db.close();
  }
}

module.exports = { NFTAPIPlugin };
----

== Registering module and plugin

Now that the NFT module and plugin have been implemented, we need to let the blockchain application know about them.

This is done by registering them with the blockchain application like shown below.

Open again the `nft/blockchain-app/index.js` file and paste the following code:

.nft/blockchain-app/index.js
[source,js]
----
// 1.Import lisk sdk to create the blockchain application
const {
	Application,
	configDevnet,
	genesisBlockDevnet,
	HTTPAPIPlugin,
	utils,
} = require('lisk-sdk');

// 2.Import NFT module and Plugin
const { NFTModule } = require('./nft-module');
const { NFTAPIPlugin } = require('./nft-api-plugin');

// 3.Update the genesis block accounts to include NFT module attributes
genesisBlockDevnet.header.timestamp = 1605699440;
genesisBlockDevnet.header.asset.accounts = genesisBlockDevnet.header.asset.accounts.map(
	(a) =>
		utils.objects.mergeDeep({}, a, {
			nft: {
				ownNFTs: [],
			},
		}),
);

// 4.Update application config to include unique label
// and communityIdentifier to mitigate transaction replay
const appConfig = utils.objects.mergeDeep({}, configDevnet, {
	label: 'nft-app',
	genesisConfig: { communityIdentifier: 'NFT' }, //In order to have a unique networkIdentifier
	logger: {
		consoleLogLevel: 'info',
	},
});

// 5.Initialize the application with genesis block and application config
const app = Application.defaultApplication(genesisBlockDevnet, appConfig);

// 6.Register custom NFT Module and Plugins
app.registerModule(NFTModule);
app.registerPlugin(HTTPAPIPlugin);
app.registerPlugin(NFTAPIPlugin);

// 7.Run the application
app
	.run()
	.then(() => console.info('NFT Blockchain running....'))
	.catch(console.error);

----

Save and close the `index.js`.

When you start the application now again with `node index.js`, the blockchain application will load the newly created NFT module and the plugins and the new features become availalbe to the blockchain application.

In the next step, we will build a simple React frontend, which allows us to interact with the blockchain application through the browser.

== Frontend application

The final part of the NFT application is the frontend application.

[NOTE]
====
The development of the frontend application is absolutely flexible, and you can use any technology stack that you feel comfortable with.

In this example, we use React to build the client application.
====

This tutorial is mainly about explaining how to build with the Lisk SDK, therefore other parts of the frontend app wont be explained in much detail.
You can get more information about how to build React application for example at the {url_react_docs}[official React documentation^].

For convenience, clone the `development` branch from the `lisk-sdk-examples` GitHub repository and use the prepared NFT frontend-app from the sdk examples.

.nft/
[source,bash]
----
git clone https://github.com/LiskHQ/lisk-sdk-examples.git
mv lisk-sdk-examples/tutorials/nft/frontend-app frontend-app
rm -r ./lisk-sdk-examples
cd frontend-app
npm i
----

At this point you can already try out the frontend an verify that the NFT blockchain application works as expected:

First open a second terminal window, navigate to `nft/blockchain-app` and start the blockchain application with `node index.js`, if it is not already running.

In the first terminal window, start the frontend application with

[source,bash]
----
npm start
----

This should open the React app in the browser under http://localhost:3000/.

=== Frontend walkabout

Before we explore the code of the frontend app, lets first take a tour through the frontend in the browser, to see how it all works together.

In the example screenshots we use the following account credentials:

[source,json]
----
{
  "artist": {
    "passphrase": "boss annual room suspect ride robot connect repeat relax govern dolphin depth",
    "binaryAddress": "lsktxksfsbmkmoto68y7edszaecgpnaxqqg7cs43d"
  },
  "collector1": {
    "passphrase": "mammal fan below aspect thing iron uniform then humble double endorse gauge",
    "binaryAddress": "lskybgqryr9tk4m3rdp66ethaf6xurm6hj8c93udo"
  },
  "collector2": {
    "passphrase": "emotion project prepare cream double damage gentle basket submit enhance between drill",
    "binaryAddress": "lskha38ewso7do8zeuqx8qnyoqd8962mk48atknbs"
  }
}
----

But you can also create new credentials by using the `Create Account` dialog.

image:tutorials/nft/02-create-account.png[]

==== The home page
image:tutorials/nft/01-home.png[]

==== Transferring funds
image:tutorials/nft/03-transfer-funds.png[]
.Logs of the blockchain app when a valid transaction is posted to the node
----
15:20:56 INFO lisk-framework: Added transaction to pool (module=lisk:app)
{
 "id": "b9d81d996886f28d2f9fd102c2d8407dc86df941eeea0b03c004080e0f100f27",
 "nonce": "0",
 "senderPublicKey": "836d4f07c7db6d10c84394c60549d3f95cf61354e2ab5b0965a3fe7120e2f70d"
}
15:21:00 INFO lisk-framework: New block added to the chain (module=lisk:app)
{
 "id": "f6d2ee7cb0e76938340f0b8a946389d518e7f27c062759f2c78f47d2841a7010",
 "height": 787,
 "numberOfTransactions": 1
}
----

==== Creating a new NFT
image:tutorials/nft/04-create-nft.png[]
image:tutorials/nft/05-home-nft.png[]

==== Transferring an NFT
image:tutorials/nft/06-transfer-nft.png[]
image:tutorials/nft/07-home-nft.png[]

==== Purchasing an NFT
image:tutorials/nft/08-purchase-nft.png[]
image:tutorials/nft/09-collector2-account-page.png[]
image:tutorials/nft/10-collector1-account-page.png[]

==== The transactions page
image:tutorials/nft/11-transactions.png[]

==== Creating non-purchasable NFTs
image:tutorials/nft/12-create-mew.png[]
image:tutorials/nft/13-home-nft.png[]

=== API related functions

.frontend-app/src/api/index.js
[source,js]
----
export const fetchNodeInfo = async () => {
  return fetch("http://localhost:4000/api/node/info")
    .then((res) => res.json())
    .then((res) => res.data);
};

export const fetchAccountInfo = async (address) => {
  return fetch(`http://localhost:4000/api/accounts/${address}`)
    .then((res) => res.json())
    .then((res) => res.data);
};

export const sendTransactions = async (tx) => {
  return fetch("http://localhost:4000/api/transactions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(tx),
  })
    .then((res) => res.json())
    .then((res) => res.data);
};

export const fetchAllNFTTokens = async () => {
  return fetch("http://localhost:8080/api/nft_tokens")
    .then((res) => res.json())
    .then((res) => res.data);
};

export const fetchNFTToken = async (id) => {
  return fetch(`http://localhost:8080/api/nft_tokens/${id}`)
    .then((res) => res.json())
    .then((res) => res.data);
};

export const getAllTransactions = async () => {
  return fetch(`http://localhost:8080/api/transactions`)
    .then((res) => res.json())
    .then((res) => {
      return res.data;
    });
};
----

=== Dialogs

==== Create account dialog

.frontend-app/src/components/dialogs/CreateAccountDialog.js
[source,jsx]
----
import React, { Fragment, useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  TextField,
} from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import { passphrase, cryptography } from "@liskhq/lisk-client";

const useStyles = makeStyles((theme) => ({
  root: {
    "& .MuiTextField-root": {
      margin: theme.spacing(1),
    },
  },
}));

export default function CreateAccountDialog(props) {
  const [data, setData] = useState({ passphrase: "", address: "" });
  const classes = useStyles();

  useEffect(() => {
    const pw = passphrase.Mnemonic.generateMnemonic();
    const address = cryptography.getBase32AddressFromPassphrase(pw).toString("hex");
    setData({ passphrase: pw, address });
  }, [props.open]);

  return (
    <Fragment>
      <Dialog open={props.open} onBackdropClick={props.handleClose} fullWidth>
        <DialogTitle id="alert-dialog-title">
          {"Please copy the address and passphrase"}
        </DialogTitle>
        <DialogContent>
          <form noValidate autoComplete="off" className={classes.root}>
            <TextField
              label="Passphrase"
              value={data.passphrase}
              fullWidth
              InputProps={{
                readOnly: true,
              }}
            />
            <TextField
              label="Address"
              value={data.address}
              fullWidth
              InputProps={{
                readOnly: true,
              }}
            />
          </form>
        </DialogContent>
      </Dialog>
    </Fragment>
  );
}
----
==== Create NFT dialog
.frontend-app/src/components/dialogs/CreateNFTTokenDialog.js
[source,jsx]
----
import React, { Fragment, useContext, useState } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  TextField,
  Button,
  DialogActions,
} from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import { NodeInfoContext } from "../../context";
import { createNFTToken } from "../../utils/transactions/create_nft_token";
import * as api from "../../api";

const useStyles = makeStyles((theme) => ({
  root: {
    "& .MuiTextField-root": {
      margin: theme.spacing(1),
    },
  },
}));

export default function CreateNFTTokenDialog(props) {
  const nodeInfo = useContext(NodeInfoContext);
  const classes = useStyles();
  const [data, setData] = useState({
    name: "",
    initValue: "",
    minPurchaseMargin: "",
    fee: "",
    passphrase: "",
  });

  const handleChange = (event) => {
    event.persist();
    setData({ ...data, [event.target.name]: event.target.value });
  };

  const handleSend = async (event) => {
    event.preventDefault();

    const res = await createNFTToken({
      ...data,
      networkIdentifier: nodeInfo.networkIdentifier,
      minFeePerByte: nodeInfo.minFeePerByte,
    });
    await api.sendTransactions(res.tx);
    props.handleClose();
  };

  return (
    <Fragment>
      <Dialog open={props.open} onBackdropClick={props.handleClose}>
        <DialogTitle id="alert-dialog-title">{"Create NFT"}</DialogTitle>
        <DialogContent>
          <form className={classes.root} noValidate autoComplete="off">
            <TextField
              label="Name"
              value={data.name}
              name="name"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Initial Token value"
              value={data.initValue}
              name="initValue"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Minimum Purchase Margin (0 - 100)"
              value={data.minPurchaseMargin}
              name="minPurchaseMargin"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Fee"
              value={data.fee}
              name="fee"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Passphrase"
              value={data.passphrase}
              name="passphrase"
              onChange={handleChange}
              fullWidth
            />
          </form>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleSend}>Create NFT</Button>
        </DialogActions>
      </Dialog>
    </Fragment>
  );
}
----
==== Purchase NFT dialog
.frontend-app/src/components/dialogs/PurchaseNFTTokenDialog.js
[source,jsx]
----
import React, { Fragment, useContext, useState } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  TextField,
  Button,
  DialogActions,
} from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import { NodeInfoContext } from "../../context";
import { purchaseNFTToken } from "../../utils/transactions/purchase_nft_token";
import * as api from "../../api";
import { transactions } from "@liskhq/lisk-client";

const useStyles = makeStyles((theme) => ({
  root: {
    "& .MuiTextField-root": {
      margin: theme.spacing(1),
    },
  },
}));

export default function PurchaseNFTTokenDialog(props) {
  const nodeInfo = useContext(NodeInfoContext);
  const classes = useStyles();
  const currentValue = parseFloat(
    transactions.convertBeddowsToLSK(props.token.value)
  );
  const minPurchaseMargin = parseFloat(props.token.minPurchaseMargin);
  const minPurchaseValue =
    currentValue + (currentValue * minPurchaseMargin) / 100.0;

  const [data, setData] = useState({
    name: props.token.name,
    nftId: props.token.id,
    purchaseValue: "",
    fee: "",
    passphrase: "",
  });

  const handleChange = (event) => {
    event.persist();
    setData({ ...data, [event.target.name]: event.target.value });
  };

  const handleSend = async (event) => {
    event.preventDefault();

    const res = await purchaseNFTToken({
      ...data,
      networkIdentifier: nodeInfo.networkIdentifier,
      minFeePerByte: nodeInfo.minFeePerByte,
    });
    await api.sendTransactions(res.tx);
    props.handleClose();
  };

  return (
    <Fragment>
      <Dialog open={props.open} onBackdropClick={props.handleClose}>
        <DialogTitle id="alert-dialog-title">
          {"Purchase NFT"}
        </DialogTitle>
        <DialogContent>
          <form className={classes.root} noValidate autoComplete="off">
            <TextField
              label="Token Name"
              value={data.name}
              name="name"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Token ID"
              value={data.nftId}
              name="nftId"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Purchase Value"
              value={data.purchaseValue}
              name="purchaseValue"
              onChange={handleChange}
              helperText={`Minimum purchase value: ${minPurchaseValue}`}
              fullWidth
            />
            <TextField
              label="Fee"
              value={data.fee}
              name="fee"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Passphrase"
              value={data.passphrase}
              name="passphrase"
              onChange={handleChange}
              fullWidth
            />
          </form>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleSend}>Purchase NFT</Button>
        </DialogActions>
      </Dialog>
    </Fragment>
  );
}
----
==== Transfer funds dialog
.frontend-app/src/components/dialogs/TransferFundsDialog.js
[source,jsx]
----
import React, { Fragment, useContext, useState } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  TextField,
  Button,
  DialogActions,
} from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import { NodeInfoContext } from "../../context";
import { transfer } from "../../utils/transactions/transfer";
import * as api from "../../api";

const useStyles = makeStyles((theme) => ({
  root: {
    "& .MuiTextField-root": {
      margin: theme.spacing(1),
    },
  },
}));

export default function TransferFundsDialog(props) {
  const nodeInfo = useContext(NodeInfoContext);
  const classes = useStyles();
  const [data, setData] = useState({
    recipientAddress: "",
    passphrase: "",
    amount: "",
    fee: "",
  });

  const handleChange = (event) => {
    event.persist();
    setData({ ...data, [event.target.name]: event.target.value });
  };

  const handleSend = async (event) => {
    event.preventDefault();

    const res = await transfer({
      ...data,
      networkIdentifier: nodeInfo.networkIdentifier,
      minFeePerByte: nodeInfo.minFeePerByte,
    });
    await api.sendTransactions(res.tx);
    props.handleClose();
  };

  return (
    <Fragment>
      <Dialog open={props.open} onBackdropClick={props.handleClose}>
        <DialogTitle id="alert-dialog-title">{"Transfer Funds"}</DialogTitle>
        <DialogContent>
          <form className={classes.root} noValidate autoComplete="off">
            <TextField
              label="Recipient Address"
              value={data.recipientAddress}
              name="recipientAddress"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Amount"
              value={data.amount}
              name="amount"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Fee"
              value={data.fee}
              name="fee"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Passphrase"
              value={data.passphrase}
              name="passphrase"
              onChange={handleChange}
              fullWidth
            />

            <Button
              onClick={() => {
                setData({
                  ...data,
                  passphrase:
                    "peanut hundred pen hawk invite exclude brain chunk gadget wait wrong ready",
                });
              }}
            >
              Use Genesis Account
            </Button>
          </form>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleSend}>Send Funds</Button>
        </DialogActions>
      </Dialog>
    </Fragment>
  );
}
----
==== Transfer NFT dialog
.frontend-app/src/components/dialogs/TransferNFTDialog.js
[source,jsx]
----
import React, { Fragment, useContext, useState } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  TextField,
  Button,
  DialogActions,
} from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import { NodeInfoContext } from "../../context";
import { transferNFT } from "../../utils/transactions/transfer_nft";
import * as api from "../../api";

const useStyles = makeStyles((theme) => ({
  root: {
    "& .MuiTextField-root": {
      margin: theme.spacing(1),
    },
  },
}));

export default function TransferNFTDialog(props) {
  const nodeInfo = useContext(NodeInfoContext);
  const classes = useStyles();

  const [data, setData] = useState({
    name: props.token.name,
    nftId: props.token.id,
    recipientAddress: "",
    fee: "",
    passphrase: "",
  });

  const handleChange = (event) => {
    event.persist();
    setData({ ...data, [event.target.name]: event.target.value });
  };

  const handleSend = async (event) => {
    event.preventDefault();

    const res = await transferNFT({
      ...data,
      networkIdentifier: nodeInfo.networkIdentifier,
      minFeePerByte: nodeInfo.minFeePerByte,
    });
    await api.sendTransactions(res.tx);
    props.handleClose();
  };

  return (
    <Fragment>
      <Dialog open={props.open} onBackdropClick={props.handleClose}>
        <DialogTitle id="alert-dialog-title">
          {"Transfer NFT"}
        </DialogTitle>
        <DialogContent>
          <form className={classes.root} noValidate autoComplete="off">
            <TextField
              label="Token Name"
              value={data.name}
              name="name"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Token ID"
              value={data.nftId}
              name="nftId"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Recipient address"
              value={data.recipientAddress}
              name="recipientAddress"
              onChange={handleChange}
              helperText={`Address of the account that will receive the NFT.`}
              fullWidth
            />
            <TextField
              label="Fee"
              value={data.fee}
              name="fee"
              onChange={handleChange}
              fullWidth
            />
            <TextField
              label="Passphrase"
              value={data.passphrase}
              name="passphrase"
              onChange={handleChange}
              fullWidth
            />
          </form>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleSend}>Transfer NFT</Button>
        </DialogActions>
      </Dialog>
    </Fragment>
  );
}
----

=== Components

==== Account component
.frontend-app/src/components/Account.js
[source,jsx]
----
import React, { useState, useEffect } from "react";
import { Container, Typography, Divider, Grid } from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import {Buffer, cryptography, transactions} from "@liskhq/lisk-client";
import NFTToken from "./NFTToken";
import { fetchNFTToken } from "../api";

const useStyles = makeStyles((theme) => ({
  propertyList: {
    listStyle: "none",

    "& li": {
      margin: theme.spacing(2, 0),
      borderBottomColor: theme.palette.divider,
      borderBottomStyle: "solid",
      borderBottomWidth: 1,

      "& dt": {
        display: "block",
        width: "100%",
        fontWeight: "bold",
        margin: theme.spacing(1, 0),
      },
      "& dd": {
        display: "block",
        width: "100%",
        margin: theme.spacing(1, 0),
      },
    },
  },
}));

export default function Account(props) {
  const [nftTokens, setNftTokens] = useState([]);
  const classes = useStyles();
  const base32UIAddress = cryptography.getBase32AddressFromAddress(Buffer.from(props.account.address, 'hex'), 'lsk').toString('binary');

  useEffect(() => {
    async function fetchData() {
      setNftTokens(
        await Promise.all(
          props.account.nft.ownNFTs.map((a) => fetchNFTToken(a))
        )
      );
    }

    fetchData();
  }, [props.account.nft.ownNFTs]);

  return (
    <Container>
      <Typography variant="h5">{base32UIAddress}</Typography>
      <Divider />
      <dl className={classes.propertyList}>
        <li>
          <dt>Balance</dt>
          <dd>
            {transactions.convertBeddowsToLSK(props.account.token.balance)}
          </dd>
          <dt>Nonce</dt>
          <dd>{props.account.sequence.nonce}</dd>
          <dt>Binary address</dt>
          <dd>{props.account.address}</dd>
        </li>
      </dl>
      <Typography variant="h6">{"NFTs"}</Typography>
      <Grid container spacing={4}>
        {nftTokens.map((item) => (
          <Grid item md={3}>
            <NFTToken item={item} key={item.address} minimum={true} />
          </Grid>
        ))}
      </Grid>
    </Container>
  );
}
----
==== Account page component
.frontend-app/src/components/AccountPage.js
[source,jsx]
----
import React, { Fragment, useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import { fetchAccountInfo } from "../api";
import Account from "./Account";
import { cryptography } from "@liskhq/lisk-client";


function AccountPage() {
  const { address } = useParams();
  const [account, setAccount] = useState({});
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    async function fetchData() {
      const binaryAddress = cryptography.getAddressFromBase32Address(address).toString('hex');
      setAccount(await fetchAccountInfo(binaryAddress));
      setLoaded(true);
    }

    fetchData();
  }, [address]);

  return loaded ? <Account account={account} /> : <Fragment></Fragment>;
}

export default AccountPage;
----
==== Home page component
.frontend-app/src/components/HomePage.js
[source,jsx]
----
import React, { Fragment, useEffect, useState } from "react";
import NFTToken from "./NFTToken";
import { Grid } from "@material-ui/core";
import { fetchAllNFTTokens } from "../api";

function HomePage() {
  const [NFTAccounts, setNFTAccounts] = useState([]);

  useEffect(() => {
    async function fetchData() {
      setNFTAccounts(await fetchAllNFTTokens());
    }
    fetchData();
  }, []);

  return (
    <Fragment>
      <Grid container spacing={4}>
        {NFTAccounts.map((item) => (
          <Grid item md={4}>
            <NFTToken item={item} key={item.id} />
          </Grid>
        ))}
      </Grid>
    </Fragment>
  );
}

export default HomePage;
----
==== NFT component
.frontend-app/src/components/NFTToken.js
[source,jsx]
----
import React, { useState } from "react";
import {
  Card,
  CardContent,
  CardActions,
  Typography,
  Link,
  Divider,
  Button,
} from "@material-ui/core";
import { makeStyles } from "@material-ui/core/styles";
import { Link as RouterLink } from "react-router-dom";
import { transactions, cryptography, Buffer } from "@liskhq/lisk-client";

import PurchaseNFTTokenDialog from "./dialogs/PurchaseNFTTokenDialog";
import TransferNFTDialog from "./dialogs/TransferNFTDialog";

const useStyles = makeStyles((theme) => ({
  propertyList: {
    listStyle: "none",

    "& li": {
      margin: theme.spacing(2, 0),
      borderBottomColor: theme.palette.divider,
      borderBottomStyle: "solid",
      borderBottomWidth: 1,

      "& dt": {
        display: "block",
        width: "100%",
        fontWeight: "bold",
        margin: theme.spacing(1, 0),
      },
      "& dd": {
        display: "block",
        width: "100%",
        margin: theme.spacing(1, 0),
      },
    },
  },
}));

export default function NFTToken(props) {
  const classes = useStyles();
  const [openPurchase, setOpenPurchase] = useState(false);
  const [openTransfer, setOpenTransfer] = useState(false);
  const base32UIAddress = cryptography.getBase32AddressFromAddress(Buffer.from(props.item.ownerAddress, 'hex'), 'lsk').toString('binary');
  return (
    <Card>
      <CardContent>
        <Typography variant="h6">{props.item.name}</Typography>
        <Divider />
        <dl className={classes.propertyList}>
          <li>
            <dt>Token ID</dt>
            <dd>{props.item.id}</dd>
          </li>
          <li>
            <dt>Token value</dt>
            <dd>{transactions.convertBeddowsToLSK(props.item.value)}</dd>
          </li>
          <li>
            <dt>Minimum Purchase Margin</dt>
            <dd>{props.item.minPurchaseMargin}</dd>
          </li>
          {!props.minimum && (
            <li>
              <dt>Current Owner</dt>
              <dd>
                <Link
                  component={RouterLink}
                  to={`/accounts/${base32UIAddress}`}
                >
                  {base32UIAddress}
                </Link>
              </dd>
            </li>
          )}
        </dl>
        <Typography variant="h6">NFT History</Typography>
        <Divider />
        {props.item.tokenHistory.map((base32UIAddress) => (
          <dl className={classes.propertyList}>
            <li>
              <dd>
                <Link
                  component={RouterLink}
                  to={`/accounts/${base32UIAddress}`}
                >
                  {base32UIAddress}
                </Link>
              </dd>
            </li>
          </dl>
        ))}

      </CardContent>
      <CardActions>
        <>
          <Button
            size="small"
            color="primary"
            onClick={() => {
              setOpenTransfer(true);
            }}
          >
            Transfer NFT
          </Button>
          <TransferNFTDialog
            open={openTransfer}
            handleClose={() => {
              setOpenTransfer(false);
            }}
            token={props.item}
          />
        </>
        {props.item.minPurchaseMargin > 0 ? (
          <>
            <Button
              size="small"
              color="primary"
              onClick={() => {
                setOpenPurchase(true);
              }}
            >
              Purchase NFT
            </Button>
            <PurchaseNFTTokenDialog
              open={openPurchase}
              handleClose={() => {
                setOpenPurchase(false);
              }}
              token={props.item}
            />
          </>
        ) : (
          <Typography variant="body">Can't purchase this token</Typography>
        )}
      </CardActions>
    </Card>
  );
}
----
==== Transactions page component
.frontend-app/src/components/TransactionsPage.js
[source,jsx]
----
import React from 'react';
import { makeStyles } from '@material-ui/core/styles';
import Paper from '@material-ui/core/Paper';
import Table from '@material-ui/core/Table';
import TableBody from '@material-ui/core/TableBody';
import TableCell from '@material-ui/core/TableCell';
import TableContainer from '@material-ui/core/TableContainer';
import TableHead from '@material-ui/core/TableHead';
import TablePagination from '@material-ui/core/TablePagination';
import TableRow from '@material-ui/core/TableRow';
import { getAllTransactions } from "../api";
import { cryptography, Buffer } from '@liskhq/lisk-client';

const columns = [
  { id: 'moduleName', label: 'ModuleName', minWidth: 100, maxWidth: 50 },
  { id: 'assetName', label: 'AssetName', minWidth: 100, maxWidth: 50 },
  { id: 'address', label: 'Address', minWidth: 170, maxWidth: 50 },
  { id: 'id', label: 'TransactionID', minWidth: 170, maxWidth: 50 },
];

const useStyles = makeStyles({
  root: {
    width: '100%',
  },
  container: {
    maxHeight: 440,
  },
});

export default function TransactionsPage() {
  const classes = useStyles();
  const [page, setPage] = React.useState(0);
  const [rowsPerPage, setRowsPerPage] = React.useState(10);
  const [Transactions, setTransactions] = React.useState([]);

  React.useEffect(() => {
    async function fetchData() {
      setTransactions(await getAllTransactions());
    }
    fetchData();
  }, []);

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(+event.target.value);
    setPage(0);
  };

  return (
    <Paper className={classes.root}>
      <TableContainer className={classes.container}>
        <Table stickyHeader aria-label="sticky table">
          <TableHead>
            <TableRow>
              {columns.map((column) => (
                <TableCell
                  key={column.id}
                  align={column.align}
                  style={{ minWidth: column.minWidth }}
                >
                  {column.label}
                </TableCell>
              ))}
            </TableRow>
          </TableHead>
          <TableBody>
            {Transactions.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((row) => {
              return (
                <TableRow hover role="checkbox" tabIndex={-1} key={row.code}>
                  {columns.map((column) => {
                    let base32UIAddress;
                    let value;
                    if (row['recipientAddress']) {
                      base32UIAddress = cryptography.getBase32AddressFromAddress(Buffer.from(row['recipientAddress'], 'hex'));
                      value = base32UIAddress;
                    } else if (row['senderPublicKey']) {
                      base32UIAddress = cryptography.getBase32AddressFromPublicKey(Buffer.from(row['senderPublicKey'], 'hex'), 'lsk').toString('binary');
                      value = base32UIAddress;
                    }
                    value = row[column.id];
                    return (
                      <TableCell key={column.id} align={column.align}>
                        {
                          column.format && typeof value === 'number' ? column.format(value) :
                            (column.id === 'address' ? base32UIAddress : value)
                        }
                      </TableCell>
                    );
                  })}
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10, 25, 100]}
        component="div"
        count={Transactions.length}
        rowsPerPage={rowsPerPage}
        page={page}
        onChangePage={handleChangePage}
        onChangeRowsPerPage={handleChangeRowsPerPage}
      />
    </Paper>
  );
}
----
