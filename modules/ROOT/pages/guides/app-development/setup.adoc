= Creating a new blockchain application
Mona Bärenfänger <mona@lightcurve.io>
// Settings
:toc: preamble
// Project URLs
:url_guide_config: guides/app-development/configuration.adoc

How to create a new blockchain application with the Lisk SDK.

== Bootstrapping a new blockchain application with Lisk Commander

=== Dependencies

* Node.js v12 (latest)

If you are using NVM, install the correct version like this:

[source,bash]
----
nvm install v12.22.1
----

=== Installing Lisk Commander

It is recommended to install Lisk Commander globally with NPM for a convenient usage of the Lisk Commander CLI.

[source,bash]
----
npm install --global lisk-commander
----

=== Initializing a new blockchain application

[source,bash]
----
mkdir newApp
cd newApp
lisk init
----

The user is asked for the application name, description, author and license after running `lisk init`.

Next, all required files are created by Lisk Commander.
----
Using template "lisk-ts"
Initializing git repository
Updating .liskrc.json file
Creating project structure
? Application name newApp
? Application description My blockchain application
? Author mona
? License ISC
   create package.json
   create .liskrc.json
   create .eslintignore
   create .eslintrc.js
   create .lintstagedrc.json
   create .prettierignore
   create .prettierrc.json
   create README.md
   create jest.config.js
   create tsconfig.json
   create bin/run
   create bin/run.cmd
   create test/.eslintrc.js
   create test/_setup.js
   create test/tsconfig.json
   create src/app/app.ts
   create src/app/index.ts
   create src/app/modules.ts
   create src/app/plugins.ts
   create src/commands/console.ts
   create src/commands/hash-onion.ts
   create src/commands/start.ts
   create test/integration/.gitkeep
   create test/network/.gitkeep
   create test/utils/config.ts
   create src/app/modules/.gitkeep
   create src/app/plugins/.gitkeep
   create src/commands/account/create.ts
   create src/commands/account/get.ts
   create src/commands/account/show.ts
   create src/commands/account/validate.ts
   create src/commands/block/get.ts
   create src/commands/blockchain/export.ts
   create src/commands/blockchain/hash.ts
   create src/commands/blockchain/import.ts
   create src/commands/blockchain/reset.ts
   create src/commands/config/create.ts
   create src/commands/config/show.ts
   create src/commands/forger-info/export.ts
   create src/commands/forger-info/import.ts
   create src/commands/forging/config.ts
   create src/commands/forging/disable.ts
   create src/commands/forging/enable.ts
   create src/commands/forging/status.ts
   create src/commands/genesis-block/create.ts
   create src/commands/node/info.ts
   create src/commands/passphrase/decrypt.ts
   create src/commands/passphrase/encrypt.ts
   create src/commands/transaction/create.ts
   create src/commands/transaction/get.ts
   create src/commands/transaction/send.ts
   create src/commands/transaction/sign.ts
   create test/commands/account/create.spec.ts
   create test/unit/modules/.gitkeep
----

As shown in the snippet above, a nre folder `src/commands/` is created, which contains all files for the available command-line commands of the application.

NOTE: The application CLI offers various commands to manage your blockchain application conveniently.

To run the application CLI, run the following command in the root folder of the application:

./newApp/
[source,bash]
----
./bin/run
----

For convenient usage of the application commands, assign an alias to the CLI command:

[source,bash]
----
alias newApp="./bin/run"
newApp
----

Running the CLI command without any arguments will display the general command reference:

.Available commands
----
My blockchain application

VERSION
  newApp/0.1.0 darwin-x64 node-v12.20.1

USAGE
  $ newApp [COMMAND]

TOPICS
  account        Commands relating to newApp accounts.
  block          Commands relating to newApp blocks.
  blockchain     Commands relating to newApp blockchain data.
  config         Commands relating to newApp node configuration.
  forger-info    Commands relating to newApp forger-info data.
  forging        Commands relating to newApp forging.
  genesis-block  Creates genesis block file.
  node           Commands relating to newApp node.
  passphrase     Commands relating to newApp passphrases.
  transaction    Commands relating to newApp transactions.

COMMANDS
  autocomplete  display autocomplete installation instructions
  console       Lisk interactive REPL session to run commands.
  hash-onion    Create hash onions to be used by the forger.
  help          display help for newApp
  start         Start Blockchain Node.
----

=== Starting the application

Use the following command to start the blockchain application.

[source,bash]
----
newApp start
----

The `start` command offers various options, allowing to further configure the application.
For example it is possible to define ports or to enable plugins which will be used by the application.

See the full llist of available parameters in the reference below.

[source,bash]
----
$ newApp start --help
Start Blockchain Node.

USAGE
  $ test510 start

OPTIONS
  -c, --config=config                                    File path to a custom config. Environment variable "LISK_CONFIG_FILE" can
                                                         also be used.

  -d, --data-path=data-path                              Directory path to specify where node data is stored. Environment variable
                                                         "LISK_DATA_PATH" can also be used.

  -l, --log=trace|debug|info|warn|error|fatal            File log level. Environment variable "LISK_FILE_LOG_LEVEL" can also be
                                                         used.

  -n, --network=network                                  [default: default] Default network config to use. Environment variable
                                                         "LISK_NETWORK" can also be used.

  -p, --port=port                                        Open port for the peer to peer incoming connections. Environment variable
                                                         "LISK_PORT" can also be used.

  --api-ipc                                              Enable IPC communication. This will load plugins as a child process and
                                                         communicate over IPC. Environment variable "LISK_API_IPC" can also be
                                                         used.

  --api-ws                                               Enable websocket communication for api-client. Environment variable
                                                         "LISK_API_WS" can also be used.

  --api-ws-port=api-ws-port                              Port to be used for api-client websocket. Environment variable
                                                         "LISK_API_WS_PORT" can also be used.

  --console-log=trace|debug|info|warn|error|fatal        Console log level. Environment variable "LISK_CONSOLE_LOG_LEVEL" can also
                                                         be used.

  --dashboard-plugin-port=dashboard-plugin-port          Port to be used for Dashboard Plugin. Environment variable
                                                         "LISK_DASHBOARD_PLUGIN_PORT" can also be used.

  --enable-dashboard-plugin                              Enable Dashboard Plugin. Environment variable
                                                         "LISK_ENABLE_DASHBOARD_PLUGIN" can also be used.

  --enable-faucet-plugin                                 Enable Faucet Plugin. Environment variable "LISK_ENABLE_FAUCET_PLUGIN" can
                                                         also be used.

  --enable-forger-plugin                                 Enable Forger Plugin. Environment variable "LISK_ENABLE_FORGER_PLUGIN" can
                                                         also be used.

  --enable-http-api-plugin                               Enable HTTP API Plugin. Environment variable "LISK_ENABLE_HTTP_API_PLUGIN"
                                                         can also be used.

  --enable-monitor-plugin                                Enable Monitor Plugin. Environment variable "LISK_ENABLE_MONITOR_PLUGIN"
                                                         can also be used.

  --enable-report-misbehavior-plugin                     Enable ReportMisbehavior Plugin. Environment variable
                                                         "LISK_ENABLE_REPORT_MISBEHAVIOR_PLUGIN" can also be used.

  --faucet-plugin-port=faucet-plugin-port                Port to be used for Faucet Plugin. Environment variable
                                                         "LISK_FAUCET_PLUGIN_PORT" can also be used.

  --http-api-plugin-port=http-api-plugin-port            Port to be used for HTTP API Plugin. Environment variable
                                                         "LISK_HTTP_API_PLUGIN_PORT" can also be used.

  --http-api-plugin-whitelist=http-api-plugin-whitelist  List of IPs in comma separated value to allow the connection. Environment
                                                         variable "LISK_HTTP_API_PLUGIN_WHITELIST" can also be used.

  --monitor-plugin-port=monitor-plugin-port              Port to be used for Monitor Plugin. Environment variable
                                                         "LISK_MONITOR_PLUGIN_PORT" can also be used.

  --monitor-plugin-whitelist=monitor-plugin-whitelist    List of IPs in comma separated value to allow the connection. Environment
                                                         variable "LISK_MONITOR_PLUGIN_WHITELIST" can also be used.

  --overwrite-config                                     Overwrite network configs if they exist already

  --seed-peers=seed-peers                                Seed peers to initially connect to in format of comma separated "ip:port".
                                                         IP can be DNS name or IPV4 format. Environment variable "LISK_SEED_PEERS"
                                                         can also be used.

EXAMPLES
  start
  start --network devnet --data-path /path/to/data-dir --log debug
  start --network devnet --api-ws
  start --network devnet --api-ws --api-ws-port 8888
  start --network devnet --port 9000
  start --network devnet --port 9002 --seed-peers 127.0.0.1:9001,127.0.0.1:9000
  start --network testnet --overwrite-config
  start --network testnet --config ~/my_custom_config.json
----

=== Generating skeletons for modules

Use the following command to generate a skeleton for a new module:

[source,bash]
----
lisk generate:module hey 1001
----

. 1st parameter (`hey`): The name of the module.
. 2nd parameter (`1001`): The ID of the module.

.Output
----
Creating module skeleton with module name "hey" and module ID "1001"
Using template "lisk-ts"
Generating module skeleton.
Registering module...
identical .liskrc.json
   create src/app/modules/hey/hey_module.ts
   create test/unit/modules/hey/hey_module.spec.ts

No change to package.json was detected. No package manager install will be executed.
----

.The skeleton for the new module
[source,typescript]
----
import { BaseModule, AfterBlockApplyContext, TransactionApplyContext, BeforeBlockApplyContext, AfterGenesisBlockApplyContext, GenesisConfig } from 'lisk-sdk';

export class HeyModule extends BaseModule {
    public actions = {
        // Example below
        // getBalance: async (params) => this._dataAccess.account.get(params.address).token.balance,
        // getBlockByID: async (params) => this._dataAccess.blocks.get(params.id),
    };
    public reducers = {
        // Example below
        // getBalance: async (
		// 	params: Record<string, unknown>,
		// 	stateStore: StateStore,
		// ): Promise<bigint> => {
		// 	const { address } = params;
		// 	if (!Buffer.isBuffer(address)) {
		// 		throw new Error('Address must be a buffer');
		// 	}
		// 	const account = await stateStore.account.getOrDefault<TokenAccount>(address);
		// 	return account.token.balance;
		// },
    };
    public name = 'hey';
    public transactionAssets = [];
    public events = [
        // Example below
        // 'hey:newBlock',
    ];
    public id = 1001;

    public constructor(genesisConfig: GenesisConfig) {
        super(genesisConfig);
    }

    // Lifecycle hooks
    public async beforeBlockApply(_input: BeforeBlockApplyContext) {
        // Get any data from stateStore using block info, below is an example getting a generator
        // const generatorAddress = getAddressFromPublicKey(_input.block.header.generatorPublicKey);
		// const generator = await _input.stateStore.account.get<TokenAccount>(generatorAddress);
    }

    public async afterBlockApply(_input: AfterBlockApplyContext) {
        // Get any data from stateStore using block info, below is an example getting a generator
        // const generatorAddress = getAddressFromPublicKey(_input.block.header.generatorPublicKey);
		// const generator = await _input.stateStore.account.get<TokenAccount>(generatorAddress);
    }

    public async beforeTransactionApply(_input: TransactionApplyContext) {
        // Get any data from stateStore using transaction info, below is an example
        // const sender = await _input.stateStore.account.getOrDefault<TokenAccount>(_input.transaction.senderAddress);
    }

    public async afterTransactionApply(_input: TransactionApplyContext) {
        // Get any data from stateStore using transaction info, below is an example
        // const sender = await _input.stateStore.account.getOrDefault<TokenAccount>(_input.transaction.senderAddress);
    }

    public async afterGenesisBlockApply(_input: AfterGenesisBlockApplyContext) {
        // Get any data from genesis block, for example get all genesis accounts
        // const genesisAccoounts = genesisBlock.header.asset.accounts;
    }
}
----

The new module is automatically registered with the application.
Check that it is included by opening the file `src/app/modules.ts`:

[source,typescript]
----
import { Application } from 'lisk-sdk';
import { HeyModule } from "./modules/hey/hey_module";

export const registerModules = (app: Application): void => {

    app.registerModule(HeyModule);
};
----

=== Generating skeletons for transaction assets

[source,bash]
----
$ lisk generate:asset hey hey 1
----

.Output
----
Creating asset skeleton with asset name "hey" and asset ID "1" for module "hey"
Using template "lisk-ts"
Generating asset skeleton.
Registering asset...
identical .liskrc.json
   create src/app/modules/hey/assets/hey_asset.ts
   create test/unit/modules/hey/assets/hey_asset.spec.ts

No change to package.json was detected. No package manager install will be executed.

Your asset is created and ready to use.
----

.The skeleton for the new transaction asset
[source,typescript]
----
import { BaseAsset, ApplyAssetContext, ValidateAssetContext } from 'lisk-sdk';

export class HeyAsset extends BaseAsset {
  public name = 'hey';
  public id = 1;

  // Define schema for asset
  public schema = {
    $id: 'hey/hey-asset',
    title: 'HeyAsset transaction asset for hey module',
    type: 'object',
    required: [],
    properties: {},
  };

  public validate({ asset }: ValidateAssetContext<{}>): void {
    // Validate your asset
  }

  public async apply({ asset, transaction, stateStore }: ApplyAssetContext<{}>): Promise<void> {
    throw new Error('Asset "hey" apply hook is not implemented.');
  }
}
----

The new transaction asset is automatically registered with the corresponding module.
Check that it is included by opening the file `src/app/modules/hey/hey_module.ts`:

[source,typescript]
----
import { HeyAsset } from "./assets/hey_asset";

export class HeyModule extends BaseModule {
    //...
    public transactionAssets = [new HeyAsset()];
    //...
}
----

=== Generating skeletons for plugins

[source,bash]
----
$ lisk generate:plugin hey
----

.Output
----
Using template "lisk-ts"
Generating plugin skeleton
Registering plugin...
identical .liskrc.json
   create src/app/plugins/hey/hey_plugin.ts
   create test/unit/plugins/hey/hey_plugin.spec.ts

No change to package.json was detected. No package manager install will be executed.

Finished creating plugin
----

.The skeleton for the new plugin
[source,typescript]
----
import { BasePlugin, PluginInfo } from 'lisk-sdk';
import type { BaseChannel, EventsDefinition, ActionsDefinition, SchemaWithDefault } from 'lisk-sdk';

 /* eslint-disable class-methods-use-this */
 /* eslint-disable  @typescript-eslint/no-empty-function */
 export class HeyPlugin extends BasePlugin {
	// private _channel!: BaseChannel;

	public static get alias(): string {
		return 'hey';
	}

	// eslint-disable-next-line @typescript-eslint/class-literal-property-style
	public static get info(): PluginInfo {
		return {
			author: 'mona',
			version: '0.1.0',
			name: 'hey',
		};
	}

	// eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
	public get defaults(): SchemaWithDefault {
		return {
			$id: '/plugins/plugin-hey/config',
			type: 'object',
			properties: {},
			required: [],
			default: {},
		}
	}

	public get events(): EventsDefinition {
		return [
			// 'block:created',
			// 'block:missed'
		];
	}

	public get actions(): ActionsDefinition {
		return {
		// 	hello: async () => { hello: 'world' },
		};
	}

		public async load(_: BaseChannel): Promise<void> {
		// this._channel = channel;
		// this._channel.once('app:ready', () => {});
	}

	public async unload(): Promise<void> {}
}
----

The new plugin is automatically registered with the application.
Check that it is included by opening the file `src/app/plugins.js`:

[source,typescript]
----
import { Application } from 'lisk-sdk';
import { HeyPlugin } from "./plugins/hey_plugin/hey_plugin";

export const registerPlugins = (app: Application): void => {

    app.registerPlugin(HeyPlugin);
};

----

== Manual Setup (without Lisk Commander)

How to create a new blockchain application manually without using the Lisk Commander.

=== Dependencies

* Node.js v12 (latest)

If you are using NVM, install the correct version like this:

[source,bash]
----
nvm install v12.22.1
----

=== Project setup

Create a new folder for the blockchain application and navigate into it.

[source,bash]
----
mkdir my_blockchain_app
cd my_blockchain_app
----

Create a `package.json` file.

[source,bash]
----
npm init --yes
----

Install the `lisk-sdk` package.

[source,bash]
----
npm i lisk-sdk
----

=== Creating a blockchain application

Create a new file `index.js`.
We want to use this file to store the code that will start the blockchain application by using the Lisk SDK.

In `index.js`, import the `Application`, `genesisBlockDevnet` and `configDevnet` from the the `lisk-sdk` package.

[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');
----

Now use the objects to create a blockchain application:

[source,js]
----
const app = Application.defaultApplication(genesisBlockDevnet, configDevnet);
----

This will create a new blockchain application that uses `genesisBlockDevnet` as the genesis block for the blockchain, and `configDevnet`to configure the application with common default options to run a node in a development network.

[NOTE]
====
The `lisk-sdk` package contains the sample objects `genesisBlockDevnet` and `configDevnet` which enable the user to quickly spin up a development blockchain network.
`genesisBlockDevnet` includes a set of preconfigured genesis delegates, that will immediately start forging on a single node to stabilize the network.
`configDevnet` includes the configuration for the Devnet.

Both objects can be customized before passing them to the `Application` instance, if desired.

More information can be found in the guide xref:{url_guide_config}[].
====

Use `app.run()` to start the application:

[source,js]
----
app
	.run()
	.then(() => app.logger.info('App started...'))
	.catch(error => {
		console.error('Faced error in application', error);
		process.exit(1);
	});
----

After adding all of the above contents, save the file.
Now it is possible to start a blockchain application with a default configuration, that will connect to a local devnet.

=== Starting the application

Start the application as shown below:

[source,bash]
----
node index.js
----

To verify the application start, check the log messages in the terminal.
If the start was successful, the application will enable forging for all genesis delegates and will start to add new blocks to the blockchain every 10 seconds.

[NOTE]
====
After completing these steps, the default blockchain application of the Lisk SDK will now be running.

It is now possible to customize your application by registering new modules and plugins, and also adjusting the genesis block and config to suit your specific use case.
====
