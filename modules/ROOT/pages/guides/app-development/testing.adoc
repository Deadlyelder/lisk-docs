= Testing the application
// Settings
:toc: preamble
// Project URLs
:url_guides_setup: guides/app-development/setup.adoc
:url_guides_module: guides/app-development/module.adoc
:url_guides_asset: guides/app-development/asset.adoc
:url_tutorials_nft: tutorials/nft.adoc
:url_reference_test_suite: references/lisk-framework/test-suite.adoc


How to use the test utility of the Lisk SDK to test your application.

.Prerequisites
[NOTE]
====
To use this guide, it is assumed that the following criteria have been met:

* Lisk Commander is installed, and a basic blockchain application is already initialized, as explained in the guide xref:{url_guides_setup}[].
* a new module has been generated like described in the guide xref:{url_guides_module}[].
* a new asset has been generated like described in the guide xref:{url_guides_asset}[].
====

To test the functionality of modules, plugins or assets conveniently, adjust the already generated test skeletons in the `test` folder of your application.

After generating a new module and asset, the corresponding skeletons for their unit tests can be found under `test/unit/modules/nft`:

./new_app/test/
----
├── _setup.js
├── commands
│   └── account
│       └── create.spec.ts
├── integration
├── network
├── tsconfig.json
├── unit
│   └── modules
│       └── nft
│           ├── assets
│           │   └── create_n_f_t_asset.spec.ts
│           └── nft_module.spec.ts
└── utils
    └── config.ts
----

== Running the test suite

It is already possible to run the test at this point, though only the most basic tests will be already implemented.

To run all test suites, execute:

./new_app/
[source,bash]
----
yarn run test
----

If the module and asset skeletons have not been edited yet, it will display the following test results

----
yarn run v1.22.10
$ jest --passWithNoTests
 PASS  test/unit/modules/nft/nft_module.spec.ts
 PASS  test/commands/account/create.spec.ts
 FAIL  test/unit/modules/nft/assets/create_n_f_t_asset.spec.ts
  ● Test suite failed to run

    src/app/modules/nft/assets/create_n_f_t_asset.ts:16:19 - error TS6133: 'asset' is declared but its value is never read.

    16   public validate({ asset }: ValidateAssetContext<Record<string, unknown>>): void {
                         ~~~~~~~~~
    src/app/modules/nft/assets/create_n_f_t_asset.ts:21:22 - error TS6198: All destructured elements are unused.

    21   public async apply({ asset, transaction, stateStore }: ApplyAssetContext<Record<string, unknown>>): Promise<void> {
                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Test Suites: 1 failed, 2 passed, 3 total
Tests:       7 todo, 5 passed, 12 total
Snapshots:   0 total
Time:        4.62 s
Ran all test suites.
----

The tests for the asset fail because the parameters in the xref:{}[validate()] and xref:{}[apply()] functions are unused at the moment.
To get rid of the error, either remove them or implement logic which uses them in the corresponding function.

== The module test skeleton

The test skeleton of a module doesn't contain any real tests in the beginning.

Use the existing structure to implement the tests needed for the module, and add more tests as required.

.test/unit/modules/nft/nft_module.spec.ts
[source,typescript]
----
// import * as modules from '../../../src/app/modules/nft'

describe('NftModuleModule', () => {
	describe('constructor', () => {
		it.todo('should have valid id');
		it.todo('should have valid name');
	});

	describe('beforeBlockApply', () => {
		it.todo('should execute before block apply');
	});
	describe('afterBlockApply', () => {
		it.todo('should execute after block apply');
	});
	describe('beforeTransactionApply', () => {
		it.todo('should execute before transaction apply');
	});
	describe('afterTransactionApply', () => {
		it.todo('should execute after transaction apply');
	});
	describe('afterGenesisBlockApply', () => {
		it.todo('should execute after genesis apply');
	});
});
----

== The asset test skeleton

The test skeleton for the asset contains already a few simple test right from the beginning.
They were automatically created during the xref:{url_guides_setup}[initialization of the application].
The rest of the tests needs to be created by the developer, to test all the custom logic of the asset, which was implemented after the initialization of the application.

.test/unit/modules/nft/create_n_f_t_asset.spec.ts
[source,typescript]
----
import { CreateNFTAsset } from '../../../../../src/app/modules/nft/assets/create_n_f_t_asset';

describe('CreateNFTAsset', () => {
  let transactionAsset: CreateNFTAsset;

	beforeEach(() => {
		transactionAsset = new CreateNFTAsset();
	});

	describe('constructor', () => {
		it('should have valid id', () => {
			expect(transactionAsset.id).toEqual(0);
		});

		it('should have valid name', () => {
			expect(transactionAsset.name).toEqual('createNFT');
		});

		it('should have valid schema', () => {
			expect(transactionAsset.schema).toMatchSnapshot();
		});
	});

	describe('validate', () => {
		describe('schema validation', () => {
            it.todo('should throw errors for invalid schema');
            it.todo('should be ok for valid schema');
        });
	});

	describe('apply', () => {
        describe('valid cases', () => {
            it.todo('should update the state store');
        });

        describe('invalid cases', () => {
            it.todo('should throw error');
        });
	});
});
----

== Example: Unit test for a transaction asset

In this example, the test suite of the Lisk SDK is used to write some simple unit tests for a new transaction asset that we created recently.

[TIP]

====
For more information about the different features of the test suite, check out the reference page xref:{url_reference_test_suite}[]
====

=== Importing the test suite

=== The createNFT asset

The `createNFT` asset is an example asset from the previous guide xref:{url_guides_asset}[] and comes originally from the NFT app of the xref:{url_tutorials_nft}[NFT tutorial].

[source,js]
----
const { BaseAsset } = require("lisk-sdk");
const {
  getAllNFTTokens,
  setAllNFTTokens,
  createNFTToken,
} = require("../nft");

// 1.extend base asset to implement your custom asset
class CreateNFTAsset extends BaseAsset {
  // 2.define unique asset name and id
  name = "createNFT";
  id = 0;
  // 3.define asset schema for serialization
  schema = {
    $id: "lisk/nft/create",
    type: "object",
    required: ["minPurchaseMargin", "initValue", "name"],
    properties: {
      minPurchaseMargin: {
        dataType: "uint32",
        minimum: 0,
        maximum: 100,
        fieldNumber: 1,
      },
      initValue: {
        dataType: "uint64",
        exclusiveMinimum: 0,
        fieldNumber: 2,
      },
      name: {
        dataType: "string",
        minLength: 3,
        maxLength: 64,
        fieldNumber: 3,
      },
    },
  };
  validate({asset}) {
    if (asset.name === "Mewtwo") {
      throw new Error("Illegal NFT name: Mewtwo");
    }
  };
  async apply({ asset, stateStore, reducerHandler, transaction }) {
    // 4.verify if sender has enough balance
    const senderAddress = transaction.senderAddress;
    const senderAccount = await stateStore.account.get(senderAddress);

    // 5.create nft
    const nftToken = createNFTToken({
      name: asset.name,
      ownerAddress: senderAddress,
      nonce: transaction.nonce,
      value: asset.initValue,
      minPurchaseMargin: asset.minPurchaseMargin,
    });

    // 6.update sender account with unique nft id
    senderAccount.nft.ownNFTs.push(nftToken.id);
    await stateStore.account.set(senderAddress, senderAccount);

    // 7.debit tokens from sender account to create nft
    await reducerHandler.invoke("token:debit", {
      address: senderAddress,
      amount: asset.initValue,
    });

    // 8.save nfts
    const allTokens = await getAllNFTTokens(stateStore);
    allTokens.push(nftToken);
    await setAllNFTTokens(stateStore, allTokens);
  }
}

module.exports = CreateNFTAsset;
----

=== Imports

Add the following lines at the top of `create_n_f_t_asset.spec.ts` to import the required resources for the tests.

[source,typescript]
----
import { CreateNFTAsset } from '../../../../../src/app/modules/nft/assets/create_n_f_t_asset';
import { StateStore, ReducerHandler, testing, validator } from 'lisk-sdk';
import { NftModule } from '../../../../../src/app/modules/nft/nft_module';
import {
    getAllNFTTokens,
    createNFTToken,
}  from "../../../../../src/app/modules/nft/nft"

export interface NFTAccountProps {
    nft: {
        ownNFTs: [];
    };
}
----

=== Testing the validate() function

[source,typescript]
----
describe('validate', () => {
    describe('schema validation', () => {
        it('should throw error if nft name equals "Mewtwo"', () => {
            const context = testing.createValidateAssetContext({
                asset: { name: 'Mewtwo', initValue: 1, minPurchaseMargin: 10 },
                transaction: { senderAddress: Buffer.alloc(0) } as any,
            });

            expect(() => transactionAsset.validate(context)).toThrow(
                'Illegal NFT name: Mewtwo',
            );
        });
        it('should be ok for valid schema', () => {
            const context = testing.createValidateAssetContext({
                asset: { name: 'Squirtle', initValue: 1, minPurchaseMargin: 10 },
                transaction: { senderAddress: Buffer.alloc(0) } as any,
            });

            expect(() => transactionAsset.validate(context)).not.toThrow();
        });
    });
});
----

=== Testing the apply() function

[source,typescript]
----
describe('apply', () => {
    let stateStore: StateStore;
    let reducerHandler: ReducerHandler;
    let account: any;
    let nftToken;
    let context;

    beforeEach(() => {
        account = testing.fixtures.createDefaultAccount<NFTAccountProps>([NftModule]);

        nftToken = createNFTToken({
            name: 'Squirtle',
            ownerAddress: account.address,
            nonce: BigInt(1),
            value: BigInt(1),
            minPurchaseMargin: 10
        });

        stateStore = new testing.mocks.StateStoreMock({
            accounts: [account],
        });

        reducerHandler = testing.mocks.reducerHandlerMock;

        context = testing.createApplyAssetContext({
            stateStore,
            asset: { name: 'Squirtle', initValue: BigInt(1), minPurchaseMargin: 10 },
            transaction: { senderAddress: account.address, nonce: BigInt(1) } as any,
        });

        jest.spyOn(stateStore.chain, 'get');
        jest.spyOn(stateStore.chain, 'set');
        jest.spyOn(reducerHandler, 'invoke');
    });

});
----

==== Valid cases

[source,typescript]
----
describe('valid cases', () => {
    it('should update sender account with unique nft id', async () => {
        await transactionAsset.apply(context);
        const updatedSender = await stateStore.account.get<NFTAccountProps>(account.address);

        expect(updatedSender.nft.ownNFTs.toString()).toEqual(nftToken.id.toString());
    });
    it('should debit the initial value from the sender account', async () => {
        await transactionAsset.apply(context);
        expect(reducerHandler.invoke).toHaveBeenCalledWith("token:debit", {
            address: account.address,
            amount: BigInt(1),
        });
    });
    it('should save the new NFT to the database', async () => {
        await transactionAsset.apply(context);
        const allTokens = await getAllNFTTokens(stateStore);
        expect(allTokens).toEqual( [nftToken]);
    });

});
----

==== Invalid cases
[source,typescript]
----
describe('invalid cases', () => {

    it('should throw error if name is already registered', async () => {
        await transactionAsset.apply(context);
        await expect(transactionAsset.apply(context)).rejects.toThrow(
            'The NFT name "Squirtle" is already registered',
        );
    });
});
----
