= Creating a custom plugin
:sectnums:
// Project URLS
:url_architecture: architecture/index.adoc#configuration
:url_guides_setup: guides/app-development/setup.adoc
:url_guides_asset: guides/app-development/transaction-asset.adoc
:url_modules_dpos: dpos-module.adoc
:url_rpc_endpoints: rpc-endpoints.adoc
:url_tutorials_hello: tutorials/hello-world.adoc

This guide explains step-by-step, how to create a custom plugin for a blockchain application built with the Lisk SDK.

.Prerequisites
[NOTE]
====
To follow this guide, the following is assumed:

* a basic blockchain application is already initiated, like explained in the previous guide xref:{url_guides_setup}[].
====

First, create a new file named after the new module, for example `my-module.js`.

----
├── blockchain_app
│   ├── index.js
│   ├── my-plugin.js
│   └── package.json
----

== Creating the plugin class

Open `my-plugin.js` and import the `BasePlugin` from the `lisk-sdk` package:

[source,js]
----
const { BasePlugin } = require('lisk-sdk');
----

Next, define a new class `MyPlugin`, which extends from the `BasePlugin`:

[source,js]
----
const { BasePlugin } = require('lisk-sdk');

class MyPlugin extends BasePlugin {

}

module.exports = MyPlugin;
----

== Setting the plugin alias

The alias of the plugin is used to identify the plugin within the application.

Define a getter `alias()`, which returns the plugin alias as string.

[source,js]
----
const { BasePlugin } = require('lisk-sdk');

class MyPlugin extends BasePlugin {
  static get alias() {
    return "MyPlugin";
  }
}

module.exports = MyPlugin;
----

== Defining the plugin meta information

Next, define a getter `info()` to return the meta information about the plugin as an object.

In this example, we parse the package information from `package.json` and return author, version and name of the package.

[source,js]
----
const { BasePlugin } = require('lisk-sdk');
const pJSON = require('../package.json');

class MyPlugin extends BasePlugin {
  static get alias() {
    return "MyPlugin";
  }

  static get info() {
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }
}

module.exports = MyPlugin;
----

== Defining the plugin configuration

A plugin can be configured by setting the related properties in the application xref:{url_architecture}[].

What properties should bbe added to the application config is defined in the `defaults()` getter.

For a better overview, create a new file `defaults.js` and define the schema for the configuration options here like in the example below:

.defaults.js
[source,js]
----
export const myConfig = {
    type: 'object',
    properties: {
        myKey1: {
            type: 'integer',
            minimum: 1,
            maximum: 9999,
        },
        myKey2: {
            type: 'array',
            items: {
                type: 'string',
            },
        },
        myKey3: {
            type: 'object',
            properties: {
                myKey4: {
                    anyOf: [{ type: 'string' }, { type: 'boolean' }],
                },
                myKey5: {
                    type: 'array',
                },
            },
            required: ['myKey4'],
        },
      },
    required: ['myKey1', 'myKey2'],
    default: {
        myKey1: 5000,
        myKey2: ['127.0.0.1']
    },
}
----

This defines that the configuration options for the plugin can be provided in the following way:

[source,js]
----
{
  //[...] other configuration options
  plugins: {
    myPlugin: {
      key1: 5000,
      key2: ['127.0.0.1'],
      key3: { // optional key
        key4: '*',
        key5: ['GET', 'POST', 'PUT']
      },
    }
  }
}
----

To make the configuration options available to the plugin, require the prepared configuration options into `my-plugin.js` and return it in the `default()` getter.

[source,js]
----
const { BasePlugin } = require('lisk-sdk');
const { myConfig } = require('./defaults');
const pJSON = require('../package.json');

class MyPlugin extends BasePlugin {
  static get alias() {
    return "MyPlugin";
  }

  static get info() {
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }

  get defaults() {
    return myConfig;
  }
}

module.exports = MyPlugin;
----

== Defining the plugin logic



[source,js]
----
const { BasePlugin, apiClient } = require('lisk-sdk');
const { myConfig } = require('./defaults');
const pJSON = require('../package.json');

class MyPlugin extends BasePlugin {
  _latestDelegate = undefined;
  _genesisBlock = undefined;

  static get alias() {
    return "MyPlugin";
  }

  static get info() {
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }

  get defaults() {
    return myConfig;
  }

  async load(channel) {
    this._api = await apiClient.createIPCClient('~/.lisk/my-app');

    channel.subscribe('app:transaction:new', (data) => {
      const txBuffer = Buffer.from(data.transaction, 'hex');
      const transaction = this._api.transaction.decode(txBuffer);
      if ( transaction.moduleID === 5 && transaction.assetID === 0 ) {
        this._latestDelegate = transaction.username;
        channel.publish('myPlugin:newDelegate', {
          name: transaction.username,
        });
      }
    });
  }

  async unload() {
  }
}

module.exports = MyPlugin;
----

== Defining the plugin interfaces

[source,js]
----
const { BasePlugin, codec } = require('lisk-sdk');
const { myConfig } = require('./defaults');
const pJSON = require('../package.json');

class MyPlugin extends BasePlugin {
  _latestDelegate = undefined;
  _genesisBlock = undefined;

  static get alias() {
    return "MyPlugin";
  }

  static get info() {
    return {
      author: pJSON.author,
      version: pJSON.version,
      name: pJSON.name,
    };
  }

  get defaults() {
    return myConfig;
  }

  get events() {
    return ['newDelegate'];
  }

  get actions() {
    return {
      getGenesisBlock: () => this._genesisBlock,
      getLatestDelegate: () => this._latestDelegate
    };
  }

  async load(channel) {
    this._api = await apiClient.createIPCClient('~/.lisk/my-app');

    channel.subscribe('app:transaction:new', (data) => {
      const txBuffer = Buffer.from(data.transaction, 'hex');
      const transaction = this._api.transaction.decode(txBuffer);
      if ( transaction.moduleID === 5 && transaction.assetID === 0 ) {
        this._latestDelegate = transaction.username;
        channel.publish('myPlugin:newDelegate', {
          name: transaction.username,
        });
      }
    });
  }

  async unload() {
  }
}

module.exports = MyPlugin;
----

== Registering the module with the application

The last thing needed to do is to register the newly created module in the application:

.index.js
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');
const { MyModule } = require('./my-module.js');

const app = Application.defaultApplication(genesisBlockDevnet, configDevnet);

app.registerModule(MyModule);

app
	.run()
	.then(() => app.logger.info('App started...'))
	.catch(error => {
		console.error('Faced error in application', error);
		process.exit(1);
	});
----

Now save and close `index.js`.
The new module `MyModule` will now be available, the next time you start the application with `node index.js`.
