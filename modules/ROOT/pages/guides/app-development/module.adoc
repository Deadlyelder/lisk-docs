= Creating a custom module
:sectnums:
// Project URLS
:url_guides_setup: guides/app-development/setup.adoc
:url_guides_asset: guides/app-development/transaction-asset.adoc
:url_rpc_endpoints: rpc-endpoints.adoc

This guide explains step-byb-step, how to create a custom module for a blockchain application built with the Lisk SDK.

.Prerequisites
[NOTE]
====
To follow this guide, the following is assumed:

* a basic blockchain application is already initiated, like explained in the previous guide xref:{url_guides_setup}[].
====

First, create a new file named after the new module, for example `my-module.js`.

//tree with standard app files + the new module
----
----

== Creating the module class

Now open `my-module.js` and import the `BaseModule` from the `lisk-sdk` package:

[source,js]
----
const { BaseModule } = require('lisk-sdk');
----

Next, define a new class `MyModule`, which extends from the `BaseModule`:

[source,js]
----
const { BaseModule } = require('lisk-sdk');

class MyModule extends BaseModule {

}

module.exports = MyModule;
----

== Setting name and ID of the module

Inside of the `myModule` class, define the different properties of the module:

`id`(number)::
The ID of the module.
Must be unique in the application.
The ID is used for example to for creation of transactions of the module.
Minimum value is `1024`.
`name`(string)::
The name of the module.
Must be unique in the application.
The name is used for example to subscribe to events, or to invoke actions of the module.

[source,js]
----
const { BaseModule } = require('lisk-sdk');

class MyModule extends BaseModule {
  id = 1024;
  name = 'my-module';
}

module.exports = MyModule;
----

== Defining the account schema

The account schema defines which propeties are added to user accounts by the module.

The new properties will be added under a key that is named after the module name.
Inside this new key, the module-specific properties for every account are saved.

DataType must be one of `string`, `bytes`, `boolean`, `uint32`, `sint32`, `uint64` or `sint64`.

[cols=",,",options="header",stripes="hover"]
|===
|Database
|JavaScript object
|JSON

|string
|string
|string

|uint32
|number
|number

|sint32
|number
|number

|uint64
|BigInt
|string

|sint64
|BigInt
|string

|bytes
|Buffer
|string in hex format

|boolean
|boolean
|boolean

|===

The schema must be defined like the example below, which is a modified JSON schema.

If the property is either an object or an array, the `type` property must be used to identify it, instead of `dataType`.

For better overview, let's create a new file `schemas.js`, which will export the account schema for our new module:

.schemas.js
[source,js]
----
export const myAccountSchema = {
  // Root type must be type object
  type: "object",
  // Properties for the object
  properties: {
    key1: {
      dataType: "string",
      fieldNumber: 1,
    },
    key2: {
      dataType: "boolean",
      fieldNumber: 2,
    },
    key3: {
      dataType: "uint64",
      fieldNumber: 3,
    },
    key4: {
      type: "object",
      fieldNumber: 4,
      properties: {
        nestedKey1: {
          dataType: "sint32",
          fieldNumber: 1,
        },
        nestedKey2: {
          dataType: "string",
          fieldNumber: 2,
        },
      },
    },
    key5: {
      type: "array",
      fieldNumber: 5,
      items: {
        type: "object",
        properties: {
          nestedArrayKey1: {
            dataType: "string",
            fieldNumber: 1,
          },
          nestedArrayKey2: {
            dataType: "boolean",
            fieldNumber: 2,
          },
        },
      },
    },
    key6: {
      type: "array",
      fieldNumber: 6,
      items: {
        dataType: "bytes",
      },
    },
  },
  // Default values for the different properties
  default: {
    key1 : "",
    key2 : false,
    key3 : 0,
    key4 : {},
    key5 : [],
    key6 : [],
  }
}
----

Now include the schema in the module:

[source,js]
----
const { BaseModule } = require('lisk-sdk');
const { myAccountSchema } = require('./schemas.js'); <1>

class MyModule extends BaseModule {
  id = 1024;
  name = 'my-module';
  accountSchema = myAccountSchema; <2>
}

module.exports = MyModule;
----

<1> Require the schema.
<2> Set the `accountSchema` of the module to the imported schema.

== Adding transaction assets to the module

A module can include various custom transaction assets, that provide new transaction types to the application.

Before a new asset can be added, it is first required to create the custom asset as described in the xref:{url_guides_asset}[] guide.

Assuming you have created an asset `myAsset` for the module, then it can be included like this:

[source,js]
----
const { BaseModule } = require('lisk-sdk');
const { myAccountSchema } = require('./schemas.js');
const { myAsset } = require('./my-asset.js');

class MyModule extends BaseModule {
  id = 1024;
  name = 'my-module';
  accountSchema = myAccountSchema;
  transactionAssets = [ new myAsset() ];
}

module.exports = MyModule;
----

== Adding an interface by providing reducers, actions and events

Each module allows to define certain reducers, actions and events, which provide the module with an interface, that allows other modules and plugins or external services to interact with the module.

TIP: See the xref:{url_rpc_endpoints}[] page for more information.

`events`::
A list of events this module emits.
Plugins and external services an subscribe to these events with the API client.
`actions`::
A list of actions that plugins and external services can invoke  via the API client.
`reducers`::
A list of actions that other modules of the application can invoke.


== Defining the lifecycle hooks

`beforeTransactionApply()`::
description
`afterTransactionApply()`::
description
`afterGenesisBlockApply()`::
description
`beforeBlockApply()`::
description
`afterBlockApply()`::
description

[source,js]
----
async beforeTransactionApply({transaction, stateStore, reducerHandler}) {
    // Code in here is applied before each transaction is applied.
};

async afterTransactionApply({transaction, stateStore, reducerHandler}) {
  // Code in here is applied after each transaction is applied.
  if (transaction.moduleID === this.id && transaction.assetID === HelloAssetID) {

    const helloAsset = codec.decode(
      helloAssetSchema,
      transaction.asset
    );

    this._channel.publish('hello:newHello', {
      sender: transaction._senderAddress.toString('hex'),
      hello: helloAsset.helloString
    });
  }
};
async afterGenesisBlockApply({genesisBlock, stateStore, reducerHandler}) {
  // Set the hello counter to zero after the genesis block is applied
  await stateStore.chain.set(
    CHAIN_STATE_HELLO_COUNTER,
    codec.encode(helloCounterSchema, { helloCounter: 0 })
  );
};
async beforeBlockApply(context) {
    // Code in here is applied before each block is applied.
}
async afterBlockApply(context) {
    // Code in here is applied after each block is applied.
}
----

== Registering the module with the application

//is there need to update the genesis block like in hello world?
.index.js
[source,js]
----
const { Application, genesisBlockDevnet, configDevnet } = require('lisk-sdk');
const { MyModule } = require('./my-module.js');

const app = Application.defaultApplication(genesisBlockDevnet, configDevnet);

app
	.run()
	.then(() => app.logger.info('App started...'))
	.catch(error => {
		console.error('Faced error in application', error);
		process.exit(1);
	});
----
