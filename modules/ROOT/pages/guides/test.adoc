= Testing
Mona Bärenfänger <mona@lightcurve.io>
:source-linenums-option:
:highlightjs-theme: solarized_dark
:url_unit_tests: https://en.wikipedia.org/wiki/Unit_testing
:url_wiki_stubs: https://en.wikipedia.org/wiki/Test_stub

:url_tutorials_transport_3: tutorials/transport2.adoc#register_packet

The more complex the logic inside the custom transaction types, the more complicated it becomes to verify that the custom transaction logic is working as expected.

Therefore it is recommended to write {url_unit_tests}[unit tests], that verify the logic of the transaction type.

Especially for verifying the code of the `undoAsset()` function, it is convenient to write unit tests.
This is due to the fact that the code in the `undoAsset` function is only executed, if the node discovers itself on a fork with the main chain.

[NOTE]
====
To be on a **fork** means that the node added some different blocks to the chain than its peers.
In order to sync again with the network, it has to remove the blocks that are different, and undo the transactions inside these blocks.
To undo the transaction, the `undoAsset()` function will be called for each transaction inside of the blocks that need to be discarded.
====

To test if the transaction is undone correctly, write a unit test as shown in the following snippet for the `undoAsset()` method of the xref:{url_tutorials_transport_3}[supply chain tutorial: RegisterPacketTransaction]

The `undoAsset()` method of the `RegisterPacketTransaction`:

[source,js]
----
undoAsset(store) {
    const errors = [];

    /* --- Revert sender account --- */
    const sender = store.account.get(this.senderId);
    const senderBalanceWithPostage = new utils.BigNum(sender.balance).add(
        new utils.BigNum(this.asset.postage)
    );
    const updatedSender = {
        ...sender,
        balance: senderBalanceWithPostage.toString()
    };
    store.account.set(sender.address, updatedSender);

    /* --- Revert packet account --- */
    const packet = store.account.get(this.asset.packetId);
    const originalPacketAccount = { ...packet, balance: 0, asset: null };
    store.account.set(packet.address, originalPacketAccount);

    return errors;
}
----

* Line `6-12`: The postage is added back to the senders' account balance.
* Line `13`: The sender account with the updated balance is saved in the database.
* Line `16-17`: The postage is removed from the packet account balance
* Line `18`: The packet account with the updated balance is saved in the database.

.Example: Unit test for the undoAsset() function of the RegisterPacketTransaction
[source,js]
----
const RegisterPacketTransaction = require('../register-packet');
const transactions = require('@liskhq/lisk-transactions');
const { when } = require('jest-when');

describe('RegisterPacket Transaction', () => {
    let storeStub;
    beforeEach(() => {
        storeStub = { <1>
            account: {
                get: jest.fn(),
                set: jest.fn(),
            },
        };
    });

    test('it should undo the state for register packet correctly', async () => { <2>
        // Arrange
        const senderId = 'senderXYZ';
        const asset = {
            security: transactions.utils.convertLSKToBeddows('10'),
            minTrust: 0,
            postage: transactions.utils.convertLSKToBeddows('10'),
            packetId: 'not important',
            recipientId: 'xyzL',
        };

        const mockedPacketAccount = {
            address: 'xyz123',
        };
        const mockedSenderAccount = {
            address: 'abc123',
            balance: '10000000000', // 100 LSK
        };

        when(storeStub.account.get) <3>
            .calledWith(asset.packetId)
            .mockReturnValue(mockedPacketAccount);

        when(storeStub.account.get) <4>
            .calledWith(senderId)
            .mockReturnValue(mockedSenderAccount);

        // Act
        const tx = new RegisterPacketTransaction({
            senderId,
            asset,
        });
        tx.undoAsset(storeStub);

        // Assert
        expect(storeStub.account.set).toHaveBeenNthCalledWith(
            1,
            mockedPacketAccount.address,
            {
                address: mockedPacketAccount.address,
                balance: 0,
                asset: null,
            }
        );

        expect(storeStub.account.set).toHaveBeenNthCalledWith(
            2,
            mockedSenderAccount.address,
            {
                address: mockedSenderAccount.address,
                balance: new transactions.utils.BigNum(mockedSenderAccount.balance).add(
                    new transactions.utils.BigNum(asset.postage)
                ).toString()
            }
        );
    });
});
----

<1> The `get()` and `set()` functions of the `stateStore` are mocked by creating {url_wiki_stubs}[stubs] in the `beforeEach()` function.
This allows replace the call with a custom return value.
<2> Now start the test, add a short and precise description of what the test is about.

 which we do a bit down in the first test with the when(storeStub.account.get)…
So, if that functions gets called with asset.packetId for example, we return the mockedPacketAccount
So, we have all the mocks in place now

From the // Act section, we create a new transaction and call the undoAsset on this function, passing it the storeStub

Lastly, in the // Assert part we want to verify if the const asset = { … } got returned to its original state.
Therefore, we first check if the set function on the account store got called with the right parameters and returned the undo state:
{
      address: mockedPacketAccount.address,
      balance: 0,
      asset: null,
}
So, this means the undo function executed correctly
The second expect statement verifies if the sender account got reimbursed for the postage he paid

What else needs to be tested?::
Is writing unit tests really enough to ensure the functionality of a custom transaction type? +
**Short answer: The unit tests are sufficient.** +
**Explanation:** You may wonder if it is required to write additional functional and integration tests.
Be aware, that the correct reading and writing of the data to the database is already part of the Lisk SDK software testing and therefore it is not needed to test it again for your new custom transaction type.
Therefore unit tests are generally sufficient to test the functionality of a custom transaction type.
