= Testing
Mona Bärenfänger <mona@lightcurve.io>
:url_unit_tests: https://en.wikipedia.org/wiki/Unit_testing
:source-linenums-option:

:url_tutorials_transport_3: tutorials/transport2.adoc#register_packet

The more complex the logic inside the custom transaction types, the more complicated it becomes to verify that the custom transaction logic is working as expected.

Therefore it is recommended to write {url_unit_tests}[unit tests], that verify the logic of the transaction type.

Especially for verifying the code of the `undoAsset()` function, it is convenient to write unit tests.
This is due to the fact that the code in the `undoAsset` function is only executed, if the node discovers itself on a fork with the main chain.

[NOTE]
====
To be on a **fork** means that the node added some different blocks to the chain than its peers.
In order to sync again with the network, it has to remove the blocks that are different, and undo the transactions inside these blocks.
To undo the transaction, the `undoAsset()` function will be called for each transaction inside of the blocks that need to be discarded.
====

To test if the transaction is undone correctly, write a unit test as shown in the following snippet for the `undoAsset()` method of the xref:{url_tutorials_transport_3}[supply chain tutorial: RegisterPacketTransaction]

The `undoAsset()` method of the `RegisterPacketTransaction`:

[source,js]
----
undoAsset(store) {
    const errors = [];

    /* --- Revert sender account --- */
    const sender = store.account.get(this.senderId);
    const senderBalanceWithPostage = new utils.BigNum(sender.balance).add(
        new utils.BigNum(this.asset.postage)
    );
    const updatedSender = {
        ...sender,
        balance: senderBalanceWithPostage.toString()
    };
    store.account.set(sender.address, updatedSender);

    /* --- Revert packet account --- */
    const packet = store.account.get(this.asset.packetId);
    const originalPacketAccount = { ...packet, balance: 0, asset: null };
    store.account.set(packet.address, originalPacketAccount);

    return errors;
}
----

* Line `6-12`: The postage is added back to the senders' account balance.
* Line `13`: The sender account with the updated balance is saved in the database.
* Line `16-17`: The postage is removed from the packet account balance
* Line `18`: The packet account with the updated balance is saved in the database.

.Example: Unit test for the undoAsset() function of the RegisterPacketTransaction
[source,js]
----
const RegisterPacketTransaction = require('../register-packet');
const transactions = require('@liskhq/lisk-transactions');
const { when } = require('jest-when');

describe('RegisterPacket Transaction', () => {
    let storeStub;
    beforeEach(() => {
        storeStub = {
            account: {
                get: jest.fn(),
                set: jest.fn(),
            },
        };
    });

    test('it should undo the state for register packet correctly', async () => {
        // Arrange
        const senderId = 'senderXYZ';
        const asset = {
            security: transactions.utils.convertLSKToBeddows('10'),
            minTrust: 0,
            postage: transactions.utils.convertLSKToBeddows('10'),
            packetId: 'not important',
            recipientId: 'xyzL',
        };

        const mockedPacketAccount = {
            address: 'xyz123',
        };
        const mockedSenderAccount = {
            address: 'abc123',
            balance: '10000000000', // 100 LSK
        };

        when(storeStub.account.get)
            .calledWith(asset.packetId)
            .mockReturnValue(mockedPacketAccount);

        when(storeStub.account.get)
            .calledWith(senderId)
            .mockReturnValue(mockedSenderAccount);

        // Act
        const tx = new RegisterPacketTransaction({
            senderId,
            asset,
        });
        tx.undoAsset(storeStub);

        // Assert
        expect(storeStub.account.set).toHaveBeenNthCalledWith(
            1,
            mockedPacketAccount.address,
            {
                address: mockedPacketAccount.address,
                balance: 0,
                asset: null,
            }
        );

        expect(storeStub.account.set).toHaveBeenNthCalledWith(
            2,
            mockedSenderAccount.address,
            {
                address: mockedSenderAccount.address,
                balance: new transactions.utils.BigNum(mockedSenderAccount.balance).add(
                    new transactions.utils.BigNum(asset.postage)
                ).toString()
            }
        );
    });
});
----

What else needs to be tested?::
Is writing unit tests really enough to ensure the functionality of a custom transaction type? +
**Short answer: The unit tests are sufficient.** +
**Explanation:** You may wonder if it is required to write additional functional and integration tests.
Be aware, that the correct reading and writing of the data to the database is already part of the Lisk SDK software testing and therefore it is not needed to test it again for your new custom transaction type.
Therefore unit tests are generally sufficient to test the functionality of a custom transaction type.
